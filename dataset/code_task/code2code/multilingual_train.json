[
    {"id": 1, "name": "Binary search", "C#": "namespace Search {\n  using System;\n\n  public static partial class Extensions {\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) < 0 ?\n          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);\n      }\n\n      \n      \n      return right;\n    }\n\n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) <= 0 ?\n          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);\n      }\n\n      \n      \n      return left;\n    }\n  }\n}\n", "C": "#include <stdio.h>\n\nint bsearch (int *a, int n, int x) {\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        int k = i + ((j - i) / 2);\n        if (a[k] == x) {\n            return k;\n        }\n        else if (a[k] < x) {\n            i = k + 1;\n        }\n        else {\n            j = k - 1;\n        }\n    }\n    return -1;\n}\n\nint bsearch_r (int *a, int x, int i, int j) {\n    if (j < i) {\n        return -1;\n    }\n    int k = i + ((j - i) / 2);\n    if (a[k] == x) {\n        return k;\n    }\n    else if (a[k] < x) {\n        return bsearch_r(a, x, k + 1, j);\n    }\n    else {\n        return bsearch_r(a, x, i, k - 1);\n    }\n}\n\nint main () {\n    int a[] = {-31, 0, 1, 2, 2, 4, 65, 83, 99, 782};\n    int n = sizeof a / sizeof a[0];\n    int x = 2;\n    int i = bsearch(a, n, x);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    x = 5;\n    i = bsearch_r(a, x, 0, n - 1);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    return 0;\n}\n"},
    {"id": 2, "name": "MD4", "C": "\n\n\n#include <stdlib.h>\n#include <string.h>\n#include <stdint.h>\n\nchar *MD4(char *str, int len); \n\ntypedef struct string{\n        char *c;\n        int len;\n        char sign;\n}string;\n\nstatic uint32_t *MD4Digest(uint32_t *w, int len);\nstatic void setMD4Registers(uint32_t AA, uint32_t BB, uint32_t CC, uint32_t DD);\nstatic uint32_t changeEndianness(uint32_t x);\nstatic void resetMD4Registers(void);\nstatic string stringCat(string first, string second);\nstatic string uint32ToString(uint32_t l);\nstatic uint32_t stringToUint32(string s);\n\nstatic const char *BASE16 = \"0123456789abcdef=\";\n\n#define F(X,Y,Z) (((X)&(Y))|((~(X))&(Z)))\n#define G(X,Y,Z) (((X)&(Y))|((X)&(Z))|((Y)&(Z)))\n#define H(X,Y,Z) ((X)^(Y)^(Z))\n\n#define LEFTROTATE(A,N) ((A)<<(N))|((A)>>(32-(N)))\n\n#define MD4ROUND1(a,b,c,d,x,s) a += F(b,c,d) + x; a = LEFTROTATE(a, s);\n#define MD4ROUND2(a,b,c,d,x,s) a += G(b,c,d) + x + (uint32_t)0x5A827999; a = LEFTROTATE(a, s);\n#define MD4ROUND3(a,b,c,d,x,s) a += H(b,c,d) + x + (uint32_t)0x6ED9EBA1; a = LEFTROTATE(a, s);\n\nstatic uint32_t A = 0x67452301;\nstatic uint32_t B = 0xefcdab89;\nstatic uint32_t C = 0x98badcfe;\nstatic uint32_t D = 0x10325476;\n\nstring newString(char * c, int t){\n\tstring r;\n\tint i;\n\tif(c!=NULL){\n\t\tr.len = (t<=0)?strlen(c):t;\n\t\tr.c=(char *)malloc(sizeof(char)*(r.len+1));\n\t\tfor(i=0; i<r.len; i++) r.c[i]=c[i];\n\t\tr.c[r.len]='\\0';\n\t\treturn r;\n\t}\n\tr.len=t;\n\tr.c=(char *)malloc(sizeof(char)*(r.len+1));\n\tmemset(r.c,(char)0,sizeof(char)*(t+1));\n\tr.sign = 1;\n\treturn r;\n}\n\nstring stringCat(string first, string second){\n\tstring str=newString(NULL, first.len+second.len);\n\tint i;\n\n\tfor(i=0; i<first.len; i++){\n\t\tstr.c[i]=first.c[i];\n\t}\n\tfor(i=first.len; i<str.len; i++){\n\t\tstr.c[i]=second.c[i-first.len];\n\t}\n\treturn str;\n}\n\nstring base16Encode(string in){\n\tstring out=newString(NULL, in.len*2);\n\tint i,j;\n\n\tj=0;\n\tfor(i=0; i<in.len; i++){\n\t\tout.c[j++]=BASE16[((in.c[i] & 0xF0)>>4)];\n\t\tout.c[j++]=BASE16[(in.c[i] & 0x0F)];\n\t}\n\tout.c[j]='\\0';\n\treturn out;\n}\n\n\nstring uint32ToString(uint32_t l){\n\tstring s = newString(NULL,4);\n\tint i;\n\tfor(i=0; i<4; i++){\n\t\ts.c[i] = (l >> (8*(3-i))) & 0xFF;\n\t}\n\treturn s;\n}\n\nuint32_t stringToUint32(string s){\n\tuint32_t l;\n\tint i;\n\tl=0;\n\tfor(i=0; i<4; i++){\n\t\tl = l|(((uint32_t)((unsigned char)s.c[i]))<<(8*(3-i)));\n\t}\n\treturn l;\n}\n\nchar *MD4(char *str, int len){\n\tstring m=newString(str, len);\n\tstring digest;\n\tuint32_t *w;\n\tuint32_t *hash;\n\tuint64_t mlen=m.len;\n\tunsigned char oneBit = 0x80;\n\tint i, wlen;\n\n\n\tm=stringCat(m, newString((char *)&oneBit,1));\n\n\t\n\t\n\ti=((56-m.len)%64);\n\tif(i<0) i+=64;\n\tm=stringCat(m,newString(NULL, i));\n\n\tw = malloc(sizeof(uint32_t)*(m.len/4+2));\n\n\t\n\tfor(i=0; i<m.len/4; i++){\n\t\tw[i]=stringToUint32(newString(&(m.c[4*i]), 4));\n\t}\n\tw[i++] = (mlen<<3) & 0xFFFFFFFF;\n\tw[i++] = (mlen>>29) & 0xFFFFFFFF;\n\n\twlen=i;\n\n\n\t\n\tfor(i=0; i<wlen-2; i++){\n\t\tw[i]=changeEndianness(w[i]);\n\t}\n\n\thash = MD4Digest(w,wlen);\n\n\tdigest=newString(NULL,0);\n\tfor(i=0; i<4; i++){\n\t\thash[i]=changeEndianness(hash[i]);\n\t\tdigest=stringCat(digest,uint32ToString(hash[i]));\n\t}\n\n\treturn base16Encode(digest).c;\n}\n\nuint32_t *MD4Digest(uint32_t *w, int len){\n\t\n\tint i,j;\n\tuint32_t X[16];\n\tuint32_t *digest = malloc(sizeof(uint32_t)*4);\n\tuint32_t AA, BB, CC, DD;\n\n\tfor(i=0; i<len/16; i++){\n\t\tfor(j=0; j<16; j++){\n\t\t\tX[j]=w[i*16+j];\n\t\t}\n\n\t\tAA=A;\n\t\tBB=B;\n\t\tCC=C;\n\t\tDD=D;\n\n\t\tMD4ROUND1(A,B,C,D,X[0],3);\n\t\tMD4ROUND1(D,A,B,C,X[1],7);\n\t\tMD4ROUND1(C,D,A,B,X[2],11);\n\t\tMD4ROUND1(B,C,D,A,X[3],19);\n\t\tMD4ROUND1(A,B,C,D,X[4],3);\n\t\tMD4ROUND1(D,A,B,C,X[5],7);\n\t\tMD4ROUND1(C,D,A,B,X[6],11);\n\t\tMD4ROUND1(B,C,D,A,X[7],19);\n\t\tMD4ROUND1(A,B,C,D,X[8],3);\n\t\tMD4ROUND1(D,A,B,C,X[9],7);\n\t\tMD4ROUND1(C,D,A,B,X[10],11);\n\t\tMD4ROUND1(B,C,D,A,X[11],19);\n\t\tMD4ROUND1(A,B,C,D,X[12],3);\n\t\tMD4ROUND1(D,A,B,C,X[13],7);\n\t\tMD4ROUND1(C,D,A,B,X[14],11);\n\t\tMD4ROUND1(B,C,D,A,X[15],19);\n\n\t\tMD4ROUND2(A,B,C,D,X[0],3);\n\t\tMD4ROUND2(D,A,B,C,X[4],5);\n\t\tMD4ROUND2(C,D,A,B,X[8],9);\n\t\tMD4ROUND2(B,C,D,A,X[12],13);\n\t\tMD4ROUND2(A,B,C,D,X[1],3);\n\t\tMD4ROUND2(D,A,B,C,X[5],5);\n\t\tMD4ROUND2(C,D,A,B,X[9],9);\n\t\tMD4ROUND2(B,C,D,A,X[13],13);\n\t\tMD4ROUND2(A,B,C,D,X[2],3);\n\t\tMD4ROUND2(D,A,B,C,X[6],5);\n\t\tMD4ROUND2(C,D,A,B,X[10],9);\n\t\tMD4ROUND2(B,C,D,A,X[14],13);\n\t\tMD4ROUND2(A,B,C,D,X[3],3);\n\t\tMD4ROUND2(D,A,B,C,X[7],5);\n\t\tMD4ROUND2(C,D,A,B,X[11],9);\n\t\tMD4ROUND2(B,C,D,A,X[15],13);\n\n\t\tMD4ROUND3(A,B,C,D,X[0],3);\n\t\tMD4ROUND3(D,A,B,C,X[8],9);\n\t\tMD4ROUND3(C,D,A,B,X[4],11);\n\t\tMD4ROUND3(B,C,D,A,X[12],15);\n\t\tMD4ROUND3(A,B,C,D,X[2],3);\n\t\tMD4ROUND3(D,A,B,C,X[10],9);\n\t\tMD4ROUND3(C,D,A,B,X[6],11);\n\t\tMD4ROUND3(B,C,D,A,X[14],15);\n\t\tMD4ROUND3(A,B,C,D,X[1],3);\n\t\tMD4ROUND3(D,A,B,C,X[9],9);\n\t\tMD4ROUND3(C,D,A,B,X[5],11);\n\t\tMD4ROUND3(B,C,D,A,X[13],15);\n\t\tMD4ROUND3(A,B,C,D,X[3],3);\n\t\tMD4ROUND3(D,A,B,C,X[11],9);\n\t\tMD4ROUND3(C,D,A,B,X[7],11);\n\t\tMD4ROUND3(B,C,D,A,X[15],15);\n\n\t\tA+=AA;\n\t\tB+=BB;\n\t\tC+=CC;\n\t\tD+=DD;\n\t}\n\n\tdigest[0]=A;\n\tdigest[1]=B;\n\tdigest[2]=C;\n\tdigest[3]=D;\n\tresetMD4Registers();\n\treturn digest;\n}\n\nuint32_t changeEndianness(uint32_t x){\n\treturn ((x & 0xFF) << 24) | ((x & 0xFF00) << 8) | ((x & 0xFF0000) >> 8) | ((x & 0xFF000000) >> 24);\n}\n\nvoid setMD4Registers(uint32_t AA, uint32_t BB, uint32_t CC, uint32_t DD){\n\tA=AA;\n\tB=BB;\n\tC=CC;\n\tD=DD;\n}\n\nvoid resetMD4Registers(void){\n\tsetMD4Registers(0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476);\n}\n", "Go": "package main\n\nimport (\n    \"golang.org/x/crypto/md4\"\n    \"fmt\"\n)\n\nfunc main() {\n    h := md4.New()\n    h.Write([]byte(\"Rosetta Code\"))\n    fmt.Printf(\"%x\\n\", h.Sum(nil))\n}\n"},
    {"id": 3, "name": "Determine if a string is collapsible", "Go": "package main\n\nimport \"fmt\"\n\n\n\nfunc collapse(s string) (string, int, int) {\n    r := []rune(s)\n    le, del := len(r), 0\n    for i := le - 2; i >= 0; i-- {\n        if r[i] == r[i+1] {\n            copy(r[i:], r[i+1:])\n            del++\n        }\n    }\n    if del == 0 {\n        return s, le, le\n    }\n    r = r[:le-del]\n    return string(r), le, len(r)\n}\n    \nfunc main() {\n    strings:= []string {\n        \"\",\n        `\"If I were two-faced, would I be wearing this one?\" --- Abraham Lincoln `,\n        \"..1111111111111111111111111111111111111111111111111111111111111117777888\",\n        \"I never give 'em hell, I just tell the truth, and they think it's hell. \",\n        \"                                                   ---  Harry S Truman  \",\n        \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n        \"headmistressship\",\n        \"aardvark\",\n        \"😍😀🙌💃😍😍😍🙌\",\n    }\n    for _, s := range strings {\n        cs, olen, clen := collapse(s)\n        fmt.Printf(\"original : length = %2d, string = «««%s»»»\\n\", olen, s)\n        fmt.Printf(\"collapsed: length = %2d, string = «««%s»»»\\n\\n\", clen, cs)\n    }\n}\n", "Java": "\n\npublic class StringCollapsible {\n\n    public static void main(String[] args) {\n        for ( String s : new String[] {\n              \"\", \n              \"\\\"If I were two-faced, would I be wearing this one?\\\" --- Abraham Lincoln \", \n              \"..1111111111111111111111111111111111111111111111111111111111111117777888\", \n              \"I never give 'em hell, I just tell the truth, and they think it's hell. \", \n              \"                                                    --- Harry S Truman  \",\n              \"122333444455555666666777777788888888999999999\",\n              \"The better the 4-wheel drive, the further you'll be from help when ya get stuck!\",\n              \"headmistressship\"}) {\n            String result = collapse(s);\n            System.out.printf(\"old:  %2d <<<%s>>>%nnew:  %2d <<<%s>>>%n%n\", s.length(), s, result.length(), result);\n        }\n    }\n    \n    private static String collapse(String in) {\n        StringBuilder sb = new StringBuilder();\n        for ( int i = 0 ; i < in.length() ; i++ ) {\n            if ( i == 0 || in.charAt(i-1) != in.charAt(i) ) {\n                sb.append(in.charAt(i));\n            }\n        }\n        return sb.toString();\n    }\n\n}\n"},
    {"id": 4, "name": "Permutations_Derangements", "C#": "using System;\nclass Derangements\n{\n  static int n = 4;\n  static int [] buf = new int [n];\n  static bool [] used = new bool [n];\n\n  static void Main()\n  {\n    for (int i = 0; i < n; i++) used [i] = false;\n    rec(0);\n  }\n\n  static void rec(int ind)\n  {\n    for (int i = 0; i < n; i++)\n    {\n      if (!used [i] && i != ind)\n      {\n        used [i] = true;\n        buf [ind] = i;\n\tif (ind + 1 < n) rec(ind + 1);\n        else Console.WriteLine(string.Join(\",\", buf));\n\tused [i] = false;\n      }\n    }\n  }\n}\n", "C": "#include <stdio.h>\ntypedef unsigned long long LONG;\n\nLONG deranged(int depth, int len, int *d, int show)\n{\n        int i;\n        char tmp;\n        LONG count = 0;\n\n        if (depth == len) {\n                if (show) {\n                        for (i = 0; i < len; i++) putchar(d[i] + 'a');\n                        putchar('\\n');\n                }\n                return 1;\n        }\n        for (i = len - 1; i >= depth; i--) {\n                if (i == d[depth]) continue;\n\n                tmp = d[i]; d[i] = d[depth]; d[depth] = tmp;\n                count += deranged(depth + 1, len, d, show);\n                tmp = d[i]; d[i] = d[depth]; d[depth] = tmp;\n        }\n        return count;\n}\n\nLONG gen_n(int n, int show)\n{\n        LONG i;\n        int a[1024]; \n\n        for (i = 0; i < n; i++) a[i] = i;\n        return deranged(0, n, a, show);\n}\n\nLONG sub_fact(int n)\n{\n        return n < 2 ? 1 - n : (sub_fact(n - 1) + sub_fact(n - 2)) * (n - 1);\n}\n\nint main()\n{\n        int i;\n\n        printf(\"Deranged Four:\\n\");\n        gen_n(4, 1);\n\n        printf(\"\\nCompare list vs calc:\\n\");\n        for (i = 0; i < 10; i++)\n                printf(\"%d:\\t%llu\\t%llu\\n\", i, gen_n(i, 0), sub_fact(i));\n\n        printf(\"\\nfurther calc:\\n\");\n        for (i = 10; i <= 20; i++)\n                printf(\"%d: %llu\\n\", i, sub_fact(i));\n\n        return 0;\n}\n"},
    {"id": 5, "name": "IBAN", "Java": "import java.math.BigInteger;\nimport java.util.*;\n\npublic class IBAN {\n    private static final String DEFSTRS = \"\"\n            + \"AL28 AD24 AT20 AZ28 BE16 BH22 BA20 BR29 BG22 \"\n            + \"HR21 CY28 CZ24 DK18 DO28 EE20 FO18 FI18 FR27 GE22 DE22 GI23 \"\n            + \"GL18 GT28 HU28 IS26 IE22 IL23 IT27 KZ20 KW30 LV21 LB28 LI21 \"\n            + \"LT20 LU20 MK19 MT31 MR27 MU30 MC27 MD24 ME22 NL18 NO15 PK24 \"\n            + \"PS29 PL28 PT25 RO24 SM27 SA24 RS22 SK24 SI19 ES24 SE24 CH21 \"\n            + \"TN24 TR26 AE23 GB22 VG24 GR27 CR21\";\n    private static final Map<String, Integer> DEFINITIONS = new HashMap<>();\n\n    static {\n        for (String definition : DEFSTRS.split(\" \"))\n            DEFINITIONS.put(definition.substring(0, 2), Integer.parseInt(definition.substring(2)));\n    }\n\n    public static void main(String[] args) {\n        String[] ibans = {\n                \"GB82 WEST 1234 5698 7654 32\",\n                \"GB82 TEST 1234 5698 7654 32\",\n                \"GB81 WEST 1234 5698 7654 32\",\n                \"SA03 8000 0000 6080 1016 7519\",\n                \"CH93 0076 2011 6238 5295 7\",\n                \"XX00 0000\",\n                \"\",\n                \"DE\",\n                \"DE13 äöü_ 1234 1234 1234 12\"};\n        for (String iban : ibans)\n            System.out.printf(\"%s is %s.%n\", iban, validateIBAN(iban) ? \"valid\" : \"not valid\");\n    }\n\n    static boolean validateIBAN(String iban) {\n        iban = iban.replaceAll(\"\\\\s\", \"\").toUpperCase(Locale.ROOT);\n\n        int len = iban.length();\n        if (len < 4 || !iban.matches(\"[0-9A-Z]+\") || DEFINITIONS.getOrDefault(iban.substring(0, 2), 0) != len)\n            return false;\n\n        iban = iban.substring(4) + iban.substring(0, 4);\n\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < len; i++)\n            sb.append(Character.digit(iban.charAt(i), 36));\n\n        BigInteger bigInt = new BigInteger(sb.toString());\n\n        return bigInt.mod(BigInteger.valueOf(97)).intValue() == 1;\n    }\n}\n", "C": "#include <alloca.h>\n#include <ctype.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define V(cc, exp) if (!strncmp(iban, cc, 2)) return len == exp\n\n\nint valid_cc(const char *iban, int len)\n{\n    V(\"AL\", 28); V(\"AD\", 24); V(\"AT\", 20); V(\"AZ\", 28); V(\"BE\", 16); V(\"BH\", 22); V(\"BA\", 20); V(\"BR\", 29);\n    V(\"BG\", 22); V(\"CR\", 21); V(\"HR\", 21); V(\"CY\", 28); V(\"CZ\", 24); V(\"DK\", 18); V(\"DO\", 28); V(\"EE\", 20);\n    V(\"FO\", 18); V(\"FI\", 18); V(\"FR\", 27); V(\"GE\", 22); V(\"DE\", 22); V(\"GI\", 23); V(\"GR\", 27); V(\"GL\", 18);\n    V(\"GT\", 28); V(\"HU\", 28); V(\"IS\", 26); V(\"IE\", 22); V(\"IL\", 23); V(\"IT\", 27); V(\"KZ\", 20); V(\"KW\", 30);\n    V(\"LV\", 21); V(\"LB\", 28); V(\"LI\", 21); V(\"LT\", 20); V(\"LU\", 20); V(\"MK\", 19); V(\"MT\", 31); V(\"MR\", 27);\n    V(\"MU\", 30); V(\"MC\", 27); V(\"MD\", 24); V(\"ME\", 22); V(\"NL\", 18); V(\"NO\", 15); V(\"PK\", 24); V(\"PS\", 29);\n    V(\"PL\", 28); V(\"PT\", 25); V(\"RO\", 24); V(\"SM\", 27); V(\"SA\", 24); V(\"RS\", 22); V(\"SK\", 24); V(\"SI\", 19);\n    V(\"ES\", 24); V(\"SE\", 24); V(\"CH\", 21); V(\"TN\", 24); V(\"TR\", 26); V(\"AE\", 23); V(\"GB\", 22); V(\"VG\", 24);\n\n    return 0;\n}\n\n\nint strip(char *s)\n{\n    int i = -1, m = 0;\n\n    while(s[++i]) {\n        s[i - m] = s[i];\n        m += s[i] <= 32;\n    }\n\n    s[i - m] = 0;\n    return i - m;\n}\n\n\nint mod97(const char *s, int len)\n{\n    int i, j, parts = len / 7;\n    char rem[10] = \"00\";\n\n    for (i = 1; i <= parts + (len % 7 != 0); ++i) {\n        strncpy(rem + 2, s + (i - 1) * 7, 7);\n        j = atoi(rem) % 97;\n        rem[0] = j / 10 + '0';\n        rem[1] = j % 10 + '0';\n    }\n\n    return atoi(rem) % 97;\n}\n\nint valid_iban(char *iban)\n{\n    int i, j, l = 0, sz = strip(iban);\n    char *rot, *trans;\n\n    \n    for (i = 0; i < sz; ++i) {\n        if (!isdigit(iban[i]) && !isupper(iban[i]))\n            return 0;\n        l += !!isupper(iban[i]);\n    }\n\n    if (!valid_cc(iban, sz))\n        return 0;\n\n    \n    rot = alloca(sz);\n    strcpy(rot, iban + 4);\n    strncpy(rot + sz - 4, iban, 4);\n\n    \n    trans = alloca(sz + l + 1);\n    trans[sz + l] = 0;\n\n    \n    for (i = j = 0; i < sz; ++i, ++j) {\n        if (isdigit(rot[i]))\n            trans[j] = rot[i];\n        else {\n            trans[j]   = (rot[i] - 55) / 10 + '0';\n            trans[++j] = (rot[i] - 55) % 10 + '0';\n        }\n    }\n\n    return mod97(trans, sz + l) == 1;\n}\n\nint main(int _, char **argv)\n{\n    while (--_, *++argv)\n        printf(\"%s is %svalid.\\n\", *argv, valid_iban(*argv) ? \"\" : \"in\");\n\n    return 0;\n}\n"},
    {"id": 6, "name": "Find square difference", "C++": "#include <iostream>\n#include <ranges>\n\nint main()\n{\n    const int maxSquareDiff = 1000;\n    auto squareCheck = [maxSquareDiff](int i){return 2 * i - 1 > maxSquareDiff;};\n    auto answer = std::views::iota(1) |  \n      std::views::filter(squareCheck) |  \n      std::views::take(1);               \n    std::cout << answer.front() << '\\n';\n}\n", "C": "#include<stdio.h>\n#include<stdlib.h>\n\nint f(int n) {\n    int i, i1;\n    for(i=1;i*i-i1*i1<n;i1=i, i++);\n    return i;\n}\n\nint main(void) {\n    printf( \"%d\\n\", f(1000) );\n    return 0;\n}\n"},
    {"id": 7, "name": "Safe primes and unsafe primes", "Python": "primes =[]\nsp =[]\nusp=[]\nn = 10000000\nif 2<n:\n    primes.append(2)\nfor i in range(3,n+1,2):\n    for j in primes:\n        if(j>i/2) or (j==primes[-1]):\n            primes.append(i)\n            if((i-1)/2) in primes:\n                sp.append(i)\n                break\n            else:\n                usp.append(i)\n                break\n        if (i%j==0):\n            break\n\nprint('First 35 safe primes are:\\n' , sp[:35])\nprint('There are '+str(len(sp[:1000000]))+' safe primes below 1,000,000')\nprint('There are '+str(len(sp))+' safe primes below 10,000,000')\nprint('First 40 unsafe primes:\\n',usp[:40])\nprint('There are '+str(len(usp[:1000000]))+' unsafe primes below 1,000,000')\nprint('There are '+str(len(usp))+' safe primes below 10,000,000')\n", "C": "#include <stdbool.h>\n#include <stdio.h>\n\nint primes[] = {\n    2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97,\n    101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199,\n    211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331\n};\n#define PCOUNT (sizeof(primes) / sizeof(int))\n\nbool isPrime(int n) {\n    int i;\n\n    if (n < 2) {\n        return false;\n    }\n\n    for (i = 0; i < PCOUNT; i++) {\n        if (n == primes[i]) {\n            return true;\n        }\n        if (n % primes[i] == 0) {\n            return false;\n        }\n        if (n < primes[i] * primes[i]) {\n            return true;\n        }\n    }\n\n    for (i = primes[PCOUNT - 1] + 2; i * i <= n; i += 2) {\n        if (n % i == 0) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nint main() {\n    int beg, end;\n    int i, count;\n\n    \n    \n    beg = 2;\n    end = 1000000;\n    count = 0;\n    printf(\"First 35 safe primes:\\n\");\n    for (i = beg; i < end; i++) {\n        if (isPrime(i) && isPrime((i - 1) / 2)) {\n            if (count < 35) {\n                printf(\"%d \", i);\n            }\n            count++;\n        }\n    }\n    printf(\"\\nThere are  %d safe primes below  %d\\n\", count, end);\n\n    beg = end;\n    end = end * 10;\n    for (i = beg; i < end; i++) {\n        if (isPrime(i) && isPrime((i - 1) / 2)) {\n            count++;\n        }\n    }\n    printf(\"There are %d safe primes below %d\\n\", count, end);\n\n    \n    \n    beg = 2;\n    end = 1000000;\n    count = 0;\n    printf(\"\\nFirst 40 unsafe primes:\\n\");\n    for (i = beg; i < end; i++) {\n        if (isPrime(i) && !isPrime((i - 1) / 2)) {\n            if (count < 40) {\n                printf(\"%d \", i);\n            }\n            count++;\n        }\n    }\n    printf(\"\\nThere are  %d unsafe primes below  %d\\n\", count, end);\n\n    beg = end;\n    end = end * 10;\n    for (i = beg; i < end; i++) {\n        if (isPrime(i) && !isPrime((i - 1) / 2)) {\n            count++;\n        }\n    }\n    printf(\"There are %d unsafe primes below %d\\n\", count, end);\n\n    return 0;\n}\n"},
    {"id": 8, "name": "Nice primes", "C++": "#include <iostream>\n\nbool is_prime(unsigned int n) {\n    if (n < 2)\n        return false;\n    if (n % 2 == 0)\n        return n == 2;\n    if (n % 3 == 0)\n        return n == 3;\n    for (unsigned int p = 5; p * p <= n; p += 4) {\n        if (n % p == 0)\n            return false;\n        p += 2;\n        if (n % p == 0)\n            return false;\n    }\n    return true;\n}\n\nunsigned int digital_root(unsigned int n) {\n    return n == 0 ? 0 : 1 + (n - 1) % 9;\n}\n\nint main() {\n    const unsigned int from = 500, to = 1000;\n    std::cout << \"Nice primes between \" << from << \" and \" << to << \":\\n\";\n    unsigned int count = 0;\n    for (unsigned int n = from; n < to; ++n) {\n        if (is_prime(digital_root(n)) && is_prime(n)) {\n            ++count;\n            std::cout << n << (count % 10 == 0 ? '\\n' : ' ');\n        }\n    }\n    std::cout << '\\n' << count << \" nice primes found.\\n\";\n}\n", "C": "#include <stdbool.h>\n#include <stdio.h>\n\nbool is_prime(unsigned int n) {\n    if (n < 2) {\n        return false;\n    }\n    if (n % 2 == 0) {\n        return n == 2;\n    }\n    if (n % 3 == 0) {\n        return n == 3;\n    }\n    for (unsigned int p = 5; p * p <= n; p += 4) {\n        if (n % p == 0) {\n            return false;\n        }\n        p += 2;\n        if (n % p == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nunsigned int digital_root(unsigned int n) {\n    return n == 0 ? 0 : 1 + (n - 1) % 9;\n}\n\nint main() {\n    const unsigned int from = 500, to = 1000;\n    unsigned int count = 0;\n    unsigned int n;\n\n    printf(\"Nice primes between %d and %d:\\n\", from, to);\n    for (n = from; n < to; ++n) {\n        if (is_prime(digital_root(n)) && is_prime(n)) {\n            ++count;\n            \n            printf(\"%d\", n);\n            if (count % 10 == 0) {\n                putc('\\n', stdout);\n            } else {\n                putc(' ', stdout);\n            }\n        }\n    }\n    printf(\"\\n%d nice primes found.\\n\", count);\n\n    return 0;\n}\n"},
    {"id": 9, "name": "Birthday problem", "Java": "import static java.util.Arrays.stream;\nimport java.util.Random;\n\npublic class Test {\n\n    static double equalBirthdays(int nSharers, int groupSize, int nRepetitions) {\n        Random rand = new Random(1);\n\n        int eq = 0;\n\n        for (int i = 0; i < nRepetitions; i++) {\n            int[] group = new int[365];\n            for (int j = 0; j < groupSize; j++)\n                group[rand.nextInt(group.length)]++;\n            eq += stream(group).anyMatch(c -> c >= nSharers) ? 1 : 0;\n        }\n\n        return (eq * 100.0) / nRepetitions;\n    }\n\n    public static void main(String[] a) {\n\n        int groupEst = 2;\n\n        for (int sharers = 2; sharers < 6; sharers++) {\n            \n            int groupSize = groupEst + 1;\n            while (equalBirthdays(sharers, groupSize, 100) < 50.0)\n                groupSize++;\n\n            \n            int inf = (int) (groupSize - (groupSize - groupEst) / 4.0);\n            for (int gs = inf; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, groupSize, 250);\n                if (eq > 50.0) {\n                    groupSize = gs;\n                    break;\n                }\n            }\n\n            \n            for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, gs, 50_000);\n                if (eq > 50.0) {\n                    groupEst = gs;\n                    System.out.printf(\"%d independent people in a group of \"\n                            + \"%s share a common birthday. (%5.1f)%n\",\n                            sharers, gs, eq);\n                    break;\n                }\n            }\n        }\n    }\n}\n", "C++": "#include <iostream>\n#include <random>\n#include <vector>\n\ndouble equalBirthdays(int nSharers, int groupSize, int nRepetitions) {\n    std::default_random_engine generator;\n    std::uniform_int_distribution<int> distribution(0, 364);\n    std::vector<int> group(365);\n\n    int eq = 0;\n    for (int i = 0; i < nRepetitions; i++) {\n        std::fill(group.begin(), group.end(), 0);\n        for (int j = 0; j < groupSize; j++) {\n            int day = distribution(generator);\n            group[day]++;\n        }\n        if (std::any_of(group.cbegin(), group.cend(), [nSharers](int c) { return c >= nSharers; })) {\n            eq++;\n        }\n    }\n\n    return (100.0 * eq) / nRepetitions;\n}\n\nint main() {\n    int groupEst = 2;\n\n    for (int sharers = 2; sharers < 6; sharers++) {\n        \n        int groupSize = groupEst + 1;\n        while (equalBirthdays(sharers, groupSize, 100) < 50.0) {\n            groupSize++;\n        }\n\n        \n        int inf = (int)(groupSize - (groupSize - groupEst) / 4.0f);\n        for (int gs = inf; gs < groupSize + 999; gs++) {\n            double eq = equalBirthdays(sharers, groupSize, 250);\n            if (eq > 50.0) {\n                groupSize = gs;\n                break;\n            }\n        }\n\n        \n        for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {\n            double eq = equalBirthdays(sharers, gs, 50000);\n            if (eq > 50.0) {\n                groupEst = gs;\n                printf(\"%d independant people in a group of %d share a common birthday. (%5.1f)\\n\", sharers, gs, eq);\n                break;\n            }\n        }\n    }\n\n    return 0;\n}\n"},
    {"id": 10, "name": "Evaluate binomial coefficients", "C": "#include <stdio.h>\n#include <limits.h>\n\n\n\nstatic unsigned long gcd_ui(unsigned long x, unsigned long y) {\n  unsigned long t;\n  if (y < x) { t = x; x = y; y = t; }\n  while (y > 0) {\n    t = y;  y = x % y;  x = t;  \n  }\n  return x;\n}\n\nunsigned long binomial(unsigned long n, unsigned long k) {\n  unsigned long d, g, r = 1;\n  if (k == 0) return 1;\n  if (k == 1) return n;\n  if (k >= n) return (k == n);\n  if (k > n/2) k = n-k;\n  for (d = 1; d <= k; d++) {\n    if (r >= ULONG_MAX/n) {  \n      unsigned long nr, dr;  \n      g = gcd_ui(n, d);  nr = n/g;  dr = d/g;\n      g = gcd_ui(r, dr);  r = r/g;  dr = dr/g;\n      if (r >= ULONG_MAX/nr) return 0;  \n      r *= nr;\n      r /= dr;\n      n--;\n    } else {\n      r *= n--;\n      r /= d;\n    }\n  }\n  return r;\n}\n\nint main() {\n    printf(\"%lu\\n\", binomial(5, 3));\n    printf(\"%lu\\n\", binomial(40, 19));\n    printf(\"%lu\\n\", binomial(67, 31));\n    return 0;\n}\n", "C++": "double Factorial(double nValue)\n   {\n       double result = nValue;\n       double result_next;\n       double pc = nValue;\n       do\n       {\n           result_next = result*(pc-1);\n           result = result_next;\n           pc--;\n       }while(pc>2);\n       nValue = result;\n       return nValue;\n   }\n\ndouble binomialCoefficient(double n, double k)\n   {\n       if (abs(n - k) < 1e-7 || k  < 1e-7) return 1.0;\n       if( abs(k-1.0) < 1e-7 || abs(k - (n-1)) < 1e-7)return n;\n       return Factorial(n) /(Factorial(k)*Factorial((n - k)));\n   }\n"},
    {"id": 11, "name": "Collections", "C": "#define cSize( a )  ( sizeof(a)/sizeof(a[0]) ) \nint ar[10];               \nar[0] = 1;                \nar[1] = 2;\n\nint* p;                   \nfor (p=ar;                \n       p<(ar+cSize(ar));  \n       p++) {             \n  printf(\"%d\\n\",*p);      \n}                         \n", "C++": "int a[5]; \na[0] = 1; \n\nint primes[10] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; \n\n#include <string>\nstd::string strings[4]; \n                        \n"},
    {"id": 12, "name": "Julia set", "C#": "using System.Drawing;\n\n\n\nusing System.Linq;\n\nnamespace RosettaJuliaSet\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            const int w = 800;\n            const int h = 600;\n            const int zoom = 1;\n            const int maxiter = 255;\n            const int moveX = 0;\n            const int moveY = 0;\n            const double cX = -0.7;\n            const double cY = 0.27015;\n            double zx, zy, tmp;\n            int i;\n\n            var colors = (from c in Enumerable.Range(0, 256)\n                          select Color.FromArgb((c >> 5) * 36, (c >> 3 & 7) * 36, (c & 3) * 85)).ToArray();\n\n            var bitmap = new Bitmap(w, h);\n            for (int x = 0; x < w; x++)\n            {\n                for (int y = 0; y < h; y++)\n                {\n                    zx = 1.5 * (x - w / 2) / (0.5 * zoom * w) + moveX;\n                    zy = 1.0 * (y - h / 2) / (0.5 * zoom * h) + moveY;\n                    i = maxiter;\n                    while (zx * zx + zy * zy < 4 && i > 1)\n                    {\n                        tmp = zx * zx - zy * zy + cX;\n                        zy = 2.0 * zx * zy + cY;\n                        zx = tmp;\n                        i -= 1;\n                    }\n                    bitmap.SetPixel(x, y, colors[i]);\n                }\n            }\n            bitmap.Save(\"julia-set.png\");\n        }\n    }\n}\n", "C++": "#include <windows.h>\n#include <string>\n#include <complex>\n\nconst int BMP_SIZE = 600, ITERATIONS = 512;\nconst long double FCT = 2.85, hFCT = FCT / 2.0;\n\nclass myBitmap {\npublic:\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\n    ~myBitmap() {\n        DeleteObject( pen ); DeleteObject( brush );\n        DeleteDC( hdc ); DeleteObject( bmp );\n    }\n    bool create( int w, int h ) {\n        BITMAPINFO bi;\n        ZeroMemory( &bi, sizeof( bi ) );\n        bi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\n        bi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\n        bi.bmiHeader.biCompression = BI_RGB;\n        bi.bmiHeader.biPlanes      = 1;\n        bi.bmiHeader.biWidth       =  w;\n        bi.bmiHeader.biHeight      = -h;\n        HDC dc = GetDC( GetConsoleWindow() );\n        bmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\n        if( !bmp ) return false;\n        hdc = CreateCompatibleDC( dc );\n        SelectObject( hdc, bmp );\n        ReleaseDC( GetConsoleWindow(), dc );\n        width = w; height = h;\n        return true;\n    }\n    void clear( BYTE clr = 0 ) {\n        memset( pBits, clr, width * height * sizeof( DWORD ) );\n    }\n    void setBrushColor( DWORD bClr ) {\n        if( brush ) DeleteObject( brush );\n        brush = CreateSolidBrush( bClr );\n        SelectObject( hdc, brush );\n    }\n    void setPenColor( DWORD c ) {\n        clr = c; createPen();\n    }\n    void setPenWidth( int w ) {\n        wid = w; createPen();\n    }\n    void saveBitmap( std::string path ) {\n        BITMAPFILEHEADER fileheader;\n        BITMAPINFO       infoheader;\n        BITMAP           bitmap;\n        DWORD            wb;\n        GetObject( bmp, sizeof( bitmap ), &bitmap );\n        DWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\n        ZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\n        ZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\n        infoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\n        infoheader.bmiHeader.biCompression = BI_RGB;\n        infoheader.bmiHeader.biPlanes = 1;\n        infoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\n        infoheader.bmiHeader.biHeight = bitmap.bmHeight;\n        infoheader.bmiHeader.biWidth = bitmap.bmWidth;\n        infoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\n        fileheader.bfType    = 0x4D42;\n        fileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\n        fileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\n        GetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\n        HANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, \n            FILE_ATTRIBUTE_NORMAL, NULL );\n        WriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\n        WriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\n        WriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\n        CloseHandle( file );\n        delete [] dwpBits;\n    }\n    HDC getDC() const     { return hdc; }\n    int getWidth() const  { return width; }\n    int getHeight() const { return height; }\n    DWORD* bits() const { return ( DWORD* )pBits; }\nprivate:\n    void createPen() {\n        if( pen ) DeleteObject( pen );\n        pen = CreatePen( PS_SOLID, wid, clr );\n        SelectObject( hdc, pen );\n    }\n    HBITMAP bmp; HDC    hdc;\n    HPEN    pen; HBRUSH brush;\n    void    *pBits; int    width, height, wid;\n    DWORD    clr;\n};\nclass julia {\npublic:\n    void draw( std::complex<long double> k ) {\n        bmp.create( BMP_SIZE, BMP_SIZE );\n        DWORD* bits = bmp.bits();\n        int res, pos;\n        std::complex<long double> c, factor( FCT / BMP_SIZE, FCT / BMP_SIZE ) ;\n\n        for( int y = 0; y < BMP_SIZE; y++ ) {\n            pos = y * BMP_SIZE;\n\n            c.imag( ( factor.imag() * y ) + -hFCT );\n\n            for( int x = 0; x < BMP_SIZE; x++ ) {\n                c.real( factor.real() * x + -hFCT );\n                res = inSet( c, k );\n                if( res ) {\n                    int n_res = res % 255;\n                    if( res < ( ITERATIONS >> 1 ) ) res = RGB( n_res << 2, n_res << 3, n_res << 4 );\n                    else res = RGB( n_res << 4, n_res << 2, n_res << 5 );\n                }\n                bits[pos++] = res;\n            }\n        }\n        bmp.saveBitmap( \"./js.bmp\" );\n    }\nprivate:\n    int inSet( std::complex<long double> z, std::complex<long double> c ) {\n        long double dist;\n        for( int ec = 0; ec < ITERATIONS; ec++ ) {\n            z = z * z; z = z + c;\n            dist = ( z.imag() * z.imag() ) + ( z.real() * z.real() );\n            if( dist > 3 ) return( ec );\n        }\n        return 0;\n    }\n    myBitmap bmp;\n};\nint main( int argc, char* argv[] ) {\n    std::complex<long double> c;\n    long double factor = FCT / BMP_SIZE;\n    c.imag( ( factor * 184 ) + -1.4 );\n    c.real( ( factor * 307 ) + -2.0 );\n    julia j; j.draw( c ); return 0;    \n}\n"},
    {"id": 13, "name": "Birthday problem", "Java": "import static java.util.Arrays.stream;\nimport java.util.Random;\n\npublic class Test {\n\n    static double equalBirthdays(int nSharers, int groupSize, int nRepetitions) {\n        Random rand = new Random(1);\n\n        int eq = 0;\n\n        for (int i = 0; i < nRepetitions; i++) {\n            int[] group = new int[365];\n            for (int j = 0; j < groupSize; j++)\n                group[rand.nextInt(group.length)]++;\n            eq += stream(group).anyMatch(c -> c >= nSharers) ? 1 : 0;\n        }\n\n        return (eq * 100.0) / nRepetitions;\n    }\n\n    public static void main(String[] a) {\n\n        int groupEst = 2;\n\n        for (int sharers = 2; sharers < 6; sharers++) {\n            \n            int groupSize = groupEst + 1;\n            while (equalBirthdays(sharers, groupSize, 100) < 50.0)\n                groupSize++;\n\n            \n            int inf = (int) (groupSize - (groupSize - groupEst) / 4.0);\n            for (int gs = inf; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, groupSize, 250);\n                if (eq > 50.0) {\n                    groupSize = gs;\n                    break;\n                }\n            }\n\n            \n            for (int gs = groupSize - 1; gs < groupSize + 999; gs++) {\n                double eq = equalBirthdays(sharers, gs, 50_000);\n                if (eq > 50.0) {\n                    groupEst = gs;\n                    System.out.printf(\"%d independent people in a group of \"\n                            + \"%s share a common birthday. (%5.1f)%n\",\n                            sharers, gs, eq);\n                    break;\n                }\n            }\n        }\n    }\n}\n", "C": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define DEBUG 0 \n#define DAYS 365\n#define EXCESS (RAND_MAX / DAYS * DAYS)\n\nint days[DAYS];\n\ninline int rand_day(void)\n{\n\tint n;\n\twhile ((n = rand()) >= EXCESS);\n\treturn n / (EXCESS / DAYS);\n}\n\n\nint simulate1(int p, int n)\n{\n\tmemset(days, 0, sizeof(days));\n\n\twhile (p--)\n\t\tif (++days[rand_day()] == n) return 1;\n\n\treturn 0;\n}\n\n\n\n\ndouble prob(int np, int n, double n_sigmas, double p_thresh, double *std_dev)\n{\n\tdouble p, d; \n\tint runs = 0, yes = 0;\n\tdo {\n\t\tyes += simulate1(np, n);\n\t\tp = (double) yes / ++runs;\n\t\td = sqrt(p * (1 - p) / runs);\n\t\tif (DEBUG > 1)\n\t\t\tprintf(\"\\t\\t%d: %d %d %g %g        \\r\", np, yes, runs, p, d);\n\t} while (runs < 10 || fabs(p - p_thresh) < n_sigmas * d);\n\tif (DEBUG > 1) putchar('\\n');\n\n\t*std_dev = d;\n\treturn p;\n}\n\n\nint find_half_chance(int n, double *p, double *dev)\n{\n\tint lo, hi, mid;\n\nreset:\n\tlo = 0;\n\thi = DAYS * (n - 1) + 1;\n\tdo {\n\t\tmid = (hi + lo) / 2;\n\n\t\t\n\t\t\n\t\t\n\t\t*p = prob(mid, n, 5, .5, dev);\n\n\t\tif (DEBUG)\n\t\t\tprintf(\"\\t%d %d %d %g %g\\n\", lo, mid, hi, *p, *dev);\n\n\t\tif (*p < .5)\tlo = mid + 1;\n\t\telse\t\thi = mid;\n\n\t\tif (hi < lo) {\n\t\t\t\n\t\t\t\n\t\t\tif (DEBUG) puts(\"\\tMade a mess, will redo.\");\n\t\t\tgoto reset;\n\t\t}\n\t} while (lo < mid || *p < .5);\n\n\treturn mid;\n}\n\nint main(void)\n{\n\tint n, np;\n\tdouble p, d;\n\tsrand(time(0));\n\n\tfor (n = 2; n <= 5; n++) {\n\t\tnp = find_half_chance(n, &p, &d);\n\t\tprintf(\"%d collision: %d people, P = %g +/- %g\\n\",\n\t\t\tn, np, p, d);\n\t}\n\n\treturn 0;\n}\n"},
    {"id": 14, "name": "Non-decimal radices_Input", "Java": "Scanner sc = new Scanner(System.in); \nsc.useRadix(base); \nsc.nextInt(); \n", "C#": "using System;\n\nclass Program\n{\n    static void Main()\n    {\n        var value = \"100\";\n        var fromBases = new[] { 2, 8, 10, 16 };\n        var toBase = 10;\n        foreach (var fromBase in fromBases)\n        {\n            Console.WriteLine(\"{0} in base {1} is {2} in base {3}\",\n                value, fromBase, Convert.ToInt32(value, fromBase), toBase);\n        }\n    }\n}\n"},
    {"id": 15, "name": "Attractive numbers", "Python": "from sympy import sieve \n\ndef get_pfct(n): \n\ti = 2; factors = []\n\twhile i * i <= n:\n\t\tif n % i:\n\t\t\ti += 1\n\t\telse:\n\t\t\tn //= i\n\t\t\tfactors.append(i)\n\tif n > 1:\n\t\tfactors.append(n)\n\treturn len(factors) \n\nsieve.extend(110) \nprimes=sieve._list\n\npool=[]\n\nfor each in xrange(0,121):\n\tpool.append(get_pfct(each))\n\nfor i,each in enumerate(pool):\n\tif each in primes:\n\t\tprint i,\n", "C++": "#include <iostream>\n#include <iomanip>\n\n#define MAX 120\n\nusing namespace std;\n\nbool is_prime(int n) {   \n    if (n < 2) return false;\n    if (!(n % 2)) return n == 2;\n    if (!(n % 3)) return n == 3;\n    int d = 5;\n    while (d *d <= n) {\n        if (!(n % d)) return false;\n        d += 2;\n        if (!(n % d)) return false;\n        d += 4;\n    }\n    return true;\n}\n\nint count_prime_factors(int n) {    \n    if (n == 1) return 0;\n    if (is_prime(n)) return 1;\n    int count = 0, f = 2;\n    while (true) {\n        if (!(n % f)) {\n            count++;\n            n /= f;\n            if (n == 1) return count;\n            if (is_prime(n)) f = n;\n        } \n        else if (f >= 3) f += 2;\n        else f = 3;\n    }\n}\n\nint main() {\n    cout << \"The attractive numbers up to and including \" << MAX << \" are:\" << endl;\n    for (int i = 1, count = 0; i <= MAX; ++i) {\n        int n = count_prime_factors(i);\n        if (is_prime(n)) {\n            cout << setw(4) << i;\n            if (!(++count % 20)) cout << endl;\n        }\n    }\n    cout << endl;\n    return 0;\n}\n"},
    {"id": 16, "name": "Stable marriage problem", "Python": "import copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            \n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            \n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                \n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    \n                    guysfree.append(fiance)\n            else:\n                \n                if guyslist:\n                    \n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n", "C": "#include <stdio.h>\n\nint verbose = 0;\nenum {\n\tclown = -1,\n\tabe, bob, col, dan, ed, fred, gav, hal, ian, jon,\n\tabi, bea, cath, dee, eve, fay, gay, hope, ivy, jan,\n};\nconst char *name[] = {\n\t\"Abe\", \"Bob\", \"Col\",  \"Dan\", \"Ed\",  \"Fred\", \"Gav\", \"Hal\",  \"Ian\", \"Jon\",\n\t\"Abi\", \"Bea\", \"Cath\", \"Dee\", \"Eve\", \"Fay\",  \"Gay\", \"Hope\", \"Ivy\", \"Jan\"\n};\nint pref[jan + 1][jon + 1] = {\n\t{ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay },\n\t{ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay },\n\t{ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan },\n\t{ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi },\n\t{ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay },\n\t{ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay },\n\t{ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay },\n\t{ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee },\n\t{ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve },\n\t{ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope },\n\n\t{ bob, fred, jon, gav, ian, abe, dan, ed, col, hal   },\n\t{ bob, abe, col, fred, gav, dan, ian, ed, jon, hal   },\n\t{ fred, bob, ed, gav, hal, col, ian, abe, dan, jon   },\n\t{ fred, jon, col, abe, ian, hal, gav, dan, bob, ed   },\n\t{ jon, hal, fred, dan, abe, gav, col, ed, ian, bob   },\n\t{ bob, abe, ed, ian, jon, dan, fred, gav, col, hal   },\n\t{ jon, gav, hal, fred, bob, abe, col, ed, dan, ian   },\n\t{ gav, jon, bob, abe, ian, dan, hal, ed, col, fred   },\n\t{ ian, col, hal, gav, fred, bob, abe, ed, jon, dan   },\n\t{ ed, hal, gav, abe, bob, jon, col, ian, fred, dan   },\n};\nint pairs[jan + 1], proposed[jan + 1];\n\nvoid engage(int man, int woman)\n{\n\tpairs[man] = woman;\n\tpairs[woman] = man;\n\tif (verbose) printf(\"%4s is engaged to %4s\\n\", name[man], name[woman]);\n}\n\nvoid dump(int woman, int man)\n{\n\tpairs[man] = pairs[woman] = clown;\n\tif (verbose) printf(\"%4s dumps %4s\\n\", name[woman], name[man]);\n}\n\n\nint rank(int this, int that)\n{\n\tint i;\n\tfor (i = abe; i <= jon && pref[this][i] != that; i++);\n\treturn i;\n}\n\nvoid propose(int man, int woman)\n{\n\tint fiance = pairs[woman];\n\tif (verbose) printf(\"%4s proposes to %4s\\n\", name[man], name[woman]);\n\n\tif (fiance == clown) {\n\t\tengage(man, woman);\n\t} else if (rank(woman, man) < rank(woman, fiance)) {\n\t\tdump(woman, fiance);\n\t\tengage(man, woman);\n\t}\n}\n\nint covet(int man1, int wife2)\n{\n\tif (rank(man1, wife2) < rank(man1, pairs[man1]) &&\n\t\t\trank(wife2, man1) < rank(wife2, pairs[wife2])) {\n\t\tprintf( \"    %4s (w/ %4s) and %4s (w/ %4s) prefer each other\"\n\t\t\t\" over current pairing.\\n\",\n\t\t\tname[man1], name[pairs[man1]], name[wife2], name[pairs[wife2]]\n\t\t);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint thy_neighbors_wife(int man1, int man2)\n{\t\n\treturn covet(man1, pairs[man2]) + covet(man2, pairs[man1]);\n}\n\nint unstable()\n{\n\tint i, j, bad = 0;\n\tfor (i = abe; i < jon; i++) {\n\t\tfor (j = i + 1; j <= jon; j++)\n\t\t\tif (thy_neighbors_wife(i, j)) bad = 1;\n\t}\n\treturn bad;\n}\n\nint main()\n{\n\tint i, unengaged;\n\t\n\tfor (i = abe; i <= jan; i++)\n\t\tpairs[i] = proposed[i] = clown;\n\n\t\n\tdo {\n\t\tunengaged = 0;\n\t\tfor (i = abe; i <= jon; i++) {\n\t\t\n\t\t\tif (pairs[i] != clown) continue;\n\t\t\tunengaged = 1;\n\t\t\tpropose(i, pref[i][++proposed[i]]);\n\t\t}\n\t} while (unengaged);\n\n\tprintf(\"Pairing:\\n\");\n\tfor (i = abe; i <= jon; i++)\n\t\tprintf(\"  %4s - %s\\n\", name[i],\n\t\t\tpairs[i] == clown ? \"clown\" : name[pairs[i]]);\n\n\tprintf(unstable()\n\t\t? \"Marriages not stable\\n\" \n\t\t: \"Stable matchup\\n\");\n\n\tprintf(\"\\nBut if Bob and Fred were to swap:\\n\");\n\ti = pairs[bob];\n\tengage(bob, pairs[fred]);\n\tengage(fred, i);\n\tprintf(unstable() ? \"Marriages not stable\\n\" : \"Stable matchup\\n\");\n\n\treturn 0;\n}\n"},
    {"id": 17, "name": "Old lady swallowed a fly", "Java": "public class OldLadySwallowedAFly {\n\n    final static String[] data = {\n        \"_ha _c _e _p,/Quite absurd_f_p;_`cat,/Fancy that_fcat;_j`dog,/What a hog\"\n        + \"_fdog;_l`pig,/Her mouth_qso big_fpig;_d_r,/She just opened her throat_f_\"\n        + \"r;_icow,/_mhow she_ga cow;_k_o,/It_qrather wonky_f_o;_a_o_bcow,_khorse..\"\n        + \"./She's dead, of course!/\", \"_a_p_b_e \", \"/S_t \", \" to catch the \", \"fly,/Bu\"\n        + \"t _mwhy s_t fly,/Perhaps she'll die!\n        + \"t wr_nj_ntickled inside her;_aspider_b_c\", \", to_s a \", \"_sed \", \"There_qan\"\n        + \" old lady who_g\", \"_a_r_bpig,_d\", \"_acat_b_p,_\", \"_acow_b_r,_i\", \"_adog_bcat\"\n        + \",_j\", \"I don't know \", \"iggled and \", \"donkey\", \"bird\", \" was \", \"goat\", \" swal\"\n        + \"low\", \"he_gthe\"};\n\n    static boolean oldLady(String part, boolean s) {\n        for (char c : part.toCharArray()) {\n            if (s)\n                s = oldLady(data[c - '_'], false);\n            else if (c == '_')\n                s = true;\n            else\n                System.out.print(c == '/' ? '\\n' : c);\n        }\n        return s;\n    }\n\n    public static void main(String[] args) {\n        oldLady(data[0], false);\n    }\n}\n", "C": "#include <stdio.h>\nstatic char const *animals[] = {\n    \"fly\", \n    \"spider\", \n    \"bird\", \n    \"cat\", \n    \"dog\", \n    \"goat\", \n    \"cow\", \n    \"horse\"\n};\nstatic char const *verses[]  = {\n    \"I don't know why she swallowed that fly.\\nPerhaps she'll die\\n\",\n    \"That wiggled and jiggled and tickled inside her\",\n    \"How absurd, to swallow a bird\",\n    \"Imagine that. She swallowed a cat\",\n    \"What a hog to swallow a dog\",\n    \"She just opened her throat and swallowed that goat\",\n    \"I don't know how she swallowed that cow\",\n    \"She's dead of course\"\n};\n\n#define LEN(ARR) (sizeof ARR / sizeof *ARR)\n\nint main(void)\n{\n    for (size_t i = 0; i < LEN(animals); i++) {\n        printf(\"There was an old lady who swallowed a %s\\n%s\\n\", animals[i], verses[i]);\n        for (size_t j = i; j > 0 && i < LEN(animals) - 1; j--) {\n            printf(\"She swallowed the %s to catch the %s\\n\", animals[j], animals[j-1]);\n            if (j == 1) {\n                printf(\"%s\\n\", verses[0]);\n            }\n        }\n    }\n}\n"},
    {"id": 18, "name": "Haversine formula", "C#": "public static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; \n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n\n", "C": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define R 6371\n#define TO_RAD (3.1415926536 / 180)\ndouble dist(double th1, double ph1, double th2, double ph2)\n{\n\tdouble dx, dy, dz;\n\tph1 -= ph2;\n\tph1 *= TO_RAD, th1 *= TO_RAD, th2 *= TO_RAD;\n\n\tdz = sin(th1) - sin(th2);\n\tdx = cos(ph1) * cos(th1) - cos(th2);\n\tdy = sin(ph1) * cos(th1);\n\treturn asin(sqrt(dx * dx + dy * dy + dz * dz) / 2) * 2 * R;\n}\n\nint main()\n{\n\tdouble d = dist(36.12, -86.67, 33.94, -118.4);\n\t\n\tprintf(\"dist: %.1f km (%.1f mi.)\\n\", d, d / 1.609344);\n\n\treturn 0;\n}\n"},
    {"id": 19, "name": "Binary digits", "Python": ">>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n", "C": "#define _CRT_SECURE_NO_WARNINGS    \n#define _CRT_NONSTDC_NO_DEPRECATE   \n\n#include <stdio.h>\n#include <stdlib.h>\n\n\nchar* bin2str(unsigned value, char* buffer)\n{\n    \n    \n    \n    \n    \n    \n    \n\n    const unsigned N_DIGITS = sizeof(unsigned) * 8;\n    unsigned mask = 1 << (N_DIGITS - 1);\n    char* ptr = buffer;\n\n    for (int i = 0; i < N_DIGITS; i++)\n    {\n        *ptr++ = '0' + !!(value & mask);\n        mask >>= 1;\n    }\n    *ptr = '\\0';\n\n    \n    \n    for (ptr = buffer; *ptr == '0'; ptr++)\n        ;\n\n    return ptr;\n}\n\n\nchar* bin2strNaive(unsigned value, char* buffer)\n{\n    \n\n    unsigned n, m, p;\n\n    n = 0;\n    p = 1;  \n    while (p <= value / 2)\n    {\n        n = n + 1;\n        p = p * 2;\n    }\n\n    m = 0;\n    while (n > 0)\n    {\n        buffer[m] = '0' + value / p;\n        value = value % p;\n        m = m + 1;\n        n = n - 1;\n        p = p / 2;\n    }\n\n    buffer[m + 1] = '\\0';\n    return buffer;\n}\n\n\nint main(int argc, char* argv[])\n{\n    const unsigned NUMBERS[] = { 5, 50, 9000 };\n\n    const int RADIX = 2;\n    char buffer[(sizeof(unsigned)*8 + 1)];\n\n    \n    \n    \n    \n    \n    \n    \n    for (int i = 0; i < sizeof(NUMBERS) / sizeof(unsigned); i++)\n    {\n        unsigned value = NUMBERS[i];\n        itoa(value, buffer, RADIX);\n        printf(\"itoa:          %u decimal = %s binary\\n\", value, buffer);\n    }\n\n    \n    \n    \n    for (int i = 0; i < sizeof(NUMBERS) / sizeof(unsigned); i++)\n    {\n        unsigned value = NUMBERS[i];\n        printf(\"bin2str:       %u decimal = %s binary\\n\", value, bin2str(value, buffer));\n    }\n\n    \n    \n    for (int i = 0; i < sizeof(NUMBERS) / sizeof(unsigned); i++)\n    {\n        unsigned value = NUMBERS[i];\n        printf(\"bin2strNaive:  %u decimal = %s binary\\n\", value, bin2strNaive(value, buffer));\n    }\n\n    return EXIT_SUCCESS;\n}\n"},
    {"id": 20, "name": "Sexy primes", "C": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n\n#define TRUE 1\n#define FALSE 0\n\ntypedef unsigned char bool;\n\nvoid sieve(bool *c, int limit) {\n    int i, p = 3, p2;\n    \n    c[0] = TRUE;\n    c[1] = TRUE;\n    \n    for (;;) {\n        p2 = p * p;\n        if (p2 >= limit) {\n            break;\n        }\n        for (i = p2; i < limit; i += 2*p) {\n            c[i] = TRUE;\n        }\n        for (;;) {\n            p += 2;\n            if (!c[p]) {\n                break;\n            }\n        }\n    }\n}\n\nvoid printHelper(const char *cat, int len, int lim, int n) {\n    const char *sp = strcmp(cat, \"unsexy primes\") ? \"sexy prime \" : \"\";\n    const char *verb = (len == 1) ? \"is\" : \"are\";\n    printf(\"Number of %s%s less than %'d = %'d\\n\", sp, cat, lim, len);\n    printf(\"The last %d %s:\\n\", n, verb);\n}\n\nvoid printArray(int *a, int len) {\n    int i;\n    printf(\"[\");\n    for (i = 0; i < len; ++i) printf(\"%d \", a[i]);\n    printf(\"\\b]\");\n}\n\nint main() {\n    int i, ix, n, lim = 1000035;\n    int pairs = 0, trips = 0, quads = 0, quins = 0, unsexy = 2;\n    int pr = 0, tr = 0, qd = 0, qn = 0, un = 2;\n    int lpr = 5, ltr = 5, lqd = 5, lqn = 5, lun = 10;\n    int last_pr[5][2], last_tr[5][3], last_qd[5][4], last_qn[5][5];\n    int last_un[10];\n    bool *sv = calloc(lim - 1, sizeof(bool)); \n    setlocale(LC_NUMERIC, \"\");\n    sieve(sv, lim);\n\n    \n    for (i = 3; i < lim; i += 2) {\n        if (i > 5 && i < lim-6 && !sv[i] && sv[i-6] && sv[i+6]) {\n            unsexy++;\n            continue;\n        }\n        if (i < lim-6 && !sv[i] && !sv[i+6]) {\n            pairs++;\n        } else continue;\n\n        if (i < lim-12 && !sv[i+12]) {\n            trips++;\n        } else continue;\n\n        if (i < lim-18 && !sv[i+18]) {\n            quads++;\n        } else continue;\n\n        if (i < lim-24 && !sv[i+24]) {\n            quins++;\n        }\n    }\n    if (pairs < lpr) lpr = pairs;\n    if (trips < ltr) ltr = trips;\n    if (quads < lqd) lqd = quads;\n    if (quins < lqn) lqn = quins;\n    if (unsexy < lun) lun = unsexy;\n\n    \n    for (i = 3; i < lim; i += 2) {\n        if (i > 5 && i < lim-6 && !sv[i] && sv[i-6] && sv[i+6]) {\n            un++;\n            if (un > unsexy - lun) {\n                last_un[un + lun - 1 - unsexy] = i;\n            }\n            continue;\n        }\n        if (i < lim-6 && !sv[i] && !sv[i+6]) {\n            pr++;\n            if (pr > pairs - lpr) {\n                ix = pr + lpr - 1 - pairs;\n                last_pr[ix][0] = i; last_pr[ix][1] = i + 6;\n            }\n        } else continue;\n\n        if (i < lim-12 && !sv[i+12]) {\n            tr++;\n            if (tr > trips - ltr) {\n                ix = tr + ltr - 1 - trips;\n                last_tr[ix][0] = i; last_tr[ix][1] = i + 6;\n                last_tr[ix][2] = i + 12;\n            }\n        } else continue;\n\n        if (i < lim-18 && !sv[i+18]) {\n            qd++;\n            if (qd > quads - lqd) {\n                ix = qd + lqd - 1 - quads;\n                last_qd[ix][0] = i; last_qd[ix][1] = i + 6;\n                last_qd[ix][2] = i + 12; last_qd[ix][3] = i + 18;\n            }\n        } else continue;\n\n        if (i < lim-24 && !sv[i+24]) {\n            qn++;\n            if (qn > quins - lqn) {\n                ix = qn + lqn - 1 - quins;\n                last_qn[ix][0] = i; last_qn[ix][1] = i + 6;\n                last_qn[ix][2] = i + 12; last_qn[ix][3] = i + 18;\n                last_qn[ix][4] = i + 24;\n            }\n        }\n    }\n\n    printHelper(\"pairs\", pairs, lim, lpr);\n    printf(\"  [\");\n    for (i = 0; i < lpr; ++i) {\n        printArray(last_pr[i], 2);\n        printf(\"\\b] \");\n    }\n    printf(\"\\b]\\n\\n\");\n\n    printHelper(\"triplets\", trips, lim, ltr);\n    printf(\"  [\");\n    for (i = 0; i < ltr; ++i) {\n        printArray(last_tr[i], 3);\n        printf(\"\\b] \");\n    }\n    printf(\"\\b]\\n\\n\");\n\n    printHelper(\"quadruplets\", quads, lim, lqd);\n    printf(\"  [\");\n    for (i = 0; i < lqd; ++i) {\n        printArray(last_qd[i], 4);\n        printf(\"\\b] \");\n    }\n    printf(\"\\b]\\n\\n\");\n\n    printHelper(\"quintuplets\", quins, lim, lqn);\n    printf(\"  [\");\n    for (i = 0; i < lqn; ++i) {\n        printArray(last_qn[i], 5);\n        printf(\"\\b] \");\n    }\n    printf(\"\\b]\\n\\n\");\n\n    printHelper(\"unsexy primes\", unsexy, lim, lun);\n    printf(\"  [\");\n    printArray(last_un, lun);\n    printf(\"\\b]\\n\");\n    free(sv);\n    return 0;\n}\n", "C++": "#include <array>\n#include <iostream>\n#include <vector>\n#include <boost/circular_buffer.hpp>\n#include \"prime_sieve.hpp\"\n\nint main() {\n    using std::cout;\n    using std::vector;\n    using boost::circular_buffer;\n    using group_buffer = circular_buffer<vector<int>>;\n\n    const int max = 1000035;\n    const int max_group_size = 5;\n    const int diff = 6;\n    const int array_size = max + diff;\n    const int max_groups = 5;\n    const int max_unsexy = 10;\n\n    \n    prime_sieve sieve(array_size);\n\n    std::array<int, max_group_size> group_count{0};\n    vector<group_buffer> groups(max_group_size, group_buffer(max_groups));\n    int unsexy_count = 0;\n    circular_buffer<int> unsexy_primes(max_unsexy);\n    vector<int> group;\n\n    for (int p = 2; p < max; ++p) {\n        if (!sieve.is_prime(p))\n            continue;\n        if (!sieve.is_prime(p + diff) && (p - diff < 2 || !sieve.is_prime(p - diff))) {\n            \n            ++unsexy_count;\n            unsexy_primes.push_back(p);\n        } else {\n            \n            group.clear();\n            group.push_back(p);\n            for (int group_size = 1; group_size < max_group_size; group_size++) {\n                int next_p = p + group_size * diff;\n                if (next_p >= max || !sieve.is_prime(next_p))\n                    break;\n                group.push_back(next_p);\n                ++group_count[group_size];\n                groups[group_size].push_back(group);\n            }\n        }\n    }\n\n    for (int size = 1; size < max_group_size; ++size) {\n        cout << \"number of groups of size \" << size + 1 << \" is \" << group_count[size] << '\\n';\n        cout << \"last \" << groups[size].size() << \" groups of size \" << size + 1 << \":\";\n        for (const vector<int>& group : groups[size]) {\n            cout << \" (\";\n            for (size_t i = 0; i < group.size(); ++i) {\n                if (i > 0)\n                    cout << ' ';\n                cout << group[i];\n            }\n            cout << \")\";\n        }\n        cout << \"\\n\\n\";\n    }\n    cout << \"number of unsexy primes is \" << unsexy_count << '\\n';\n    cout << \"last \" << unsexy_primes.size() << \" unsexy primes:\";\n    for (int prime : unsexy_primes)\n        cout << ' ' << prime;\n    cout << '\\n';\n    return 0;\n}\n"},
    {"id": 21, "name": "Grayscale image", "Java": "void convertToGrayscale(final BufferedImage image){\n    for(int i=0; i<image.getWidth(); i++){\n        for(int j=0; j<image.getHeight(); j++){\n            int color = image.getRGB(i,j);\n\n            int alpha = (color >> 24) & 255;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n\n            final int lum = (int)(0.2126 * red + 0.7152 * green + 0.0722 * blue);\n\n            alpha = (alpha << 24);\n            red = (lum << 16);\n            green = (lum << 8);\n            blue = lum;\n\n            color = alpha + red + green + blue;\n\n            image.setRGB(i,j,color);\n        }\n    }\n}\n", "Go": "package raster\n\nimport (\n    \"math\"\n    \"math/rand\"\n)\n\n\n\ntype Grmap struct {\n    Comments   []string\n    rows, cols int\n    px         []uint16\n    pxRow      [][]uint16\n}\n\n\nfunc NewGrmap(x, y int) (b *Grmap) {\n    g := &Grmap{\n        Comments: []string{creator}, \n        rows:     y,\n        cols:     x,\n        px:       make([]uint16, x*y),\n        pxRow:    make([][]uint16, y),\n    }\n    x0, x1 := 0, x\n    for i := range g.pxRow {\n        g.pxRow[i] = g.px[x0:x1]\n        x0, x1 = x1, x1+x\n    }\n    return g\n}\n\nfunc (b *Grmap) Extent() (cols, rows int) {\n    return b.cols, b.rows\n}\n\nfunc (g *Grmap) Fill(c uint16) {\n    for i := range g.px {\n        g.px[i] = c\n    }\n}\n\nfunc (g *Grmap) SetPx(x, y int, c uint16) bool {\n    defer func() { recover() }()\n    g.pxRow[y][x] = c\n    return true\n}\n\nfunc (g *Grmap) GetPx(x, y int) (uint16, bool) {\n    defer func() { recover() }()\n    return g.pxRow[y][x], true\n}\n\n\nfunc (b *Bitmap) Grmap() *Grmap {\n    g := NewGrmap(b.cols, b.rows)\n    g.Comments = append([]string{}, b.Comments...)\n    for i, p := range b.px {\n        g.px[i] = uint16((int64(p.R)*2126 + int64(p.G)*7152 + int64(p.B)*722) *\n            math.MaxUint16 / (math.MaxUint8 * 10000))\n    }\n    return g\n}\n\n\n\nfunc (g *Grmap) Bitmap() *Bitmap {\n    b := NewBitmap(g.cols, g.rows)\n    b.Comments = append([]string{}, g.Comments...)\n    for i, p := range g.px {\n        roundedSum := int(p) * 3 * math.MaxUint8 / math.MaxUint16\n        rounded := uint8(roundedSum / 3)\n        remainder := roundedSum % 3\n        b.px[i].R = rounded\n        b.px[i].G = rounded\n        b.px[i].B = rounded\n        if remainder > 0 {\n            odd := rand.Intn(3)\n            switch odd + (remainder * 3) {\n            case 3:\n                b.px[i].R++\n            case 4:\n                b.px[i].G++\n            case 5:\n                b.px[i].B++\n            case 6:\n                b.px[i].G++\n                b.px[i].B++\n            case 7:\n                b.px[i].R++\n                b.px[i].B++\n            case 8:\n                b.px[i].R++\n                b.px[i].G++\n            }\n        }\n    }\n    return b\n}\n"},
    {"id": 22, "name": "Knight's tour", "Go": "package main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\n\nconst startRow = 0\nconst startCol = 0\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    for !knightTour() {\n    }\n}\n\nvar moves = []struct{ dr, dc int }{\n    {2, 1},\n    {2, -1},\n    {1, 2},\n    {1, -2},\n    {-1, 2},\n    {-1, -2},\n    {-2, 1},\n    {-2, -1},\n}\n\n\n\n\nfunc knightTour() bool {\n    \n    board := make([][]int, 8)\n    for i := range board {\n        board[i] = make([]int, 8)\n    }\n    r := startRow\n    c := startCol\n    board[r][c] = 1 \n    for move := 2; move <= 64; move++ {\n        minNext := 8\n        var mr, mc, nm int\n    candidateMoves:\n        for _, cm := range moves {\n            cr := r + cm.dr\n            if cr < 0 || cr >= 8 { \n                continue\n            }\n            cc := c + cm.dc\n            if cc < 0 || cc >= 8 { \n                continue\n            }\n            if board[cr][cc] > 0 { \n                continue\n            }\n            \n            p := 0 \n            for _, m2 := range moves {\n                r2 := cr + m2.dr\n                if r2 < 0 || r2 >= 8 {\n                    continue\n                }\n                c2 := cc + m2.dc\n                if c2 < 0 || c2 >= 8 {\n                    continue\n                }\n                if board[r2][c2] > 0 {\n                    continue\n                }\n                p++\n                if p > minNext { \n                    continue candidateMoves\n                }\n            }\n            if p < minNext { \n                minNext = p \n                nm = 1      \n                mr = cr     \n                mc = cc\n                continue\n            }\n            \n            \n            nm++                    \n            if rand.Intn(nm) == 0 { \n                mr = cr\n                mc = cc\n            }\n        }\n        if nm == 0 { \n            return false\n        }\n        \n        r = mr\n        c = mc\n        board[r][c] = move\n    }\n    \n    for _, r := range board {\n        for _, m := range r {\n            fmt.Printf(\"%3d\", m)\n        }\n        fmt.Println()\n    }\n    return true\n}\n", "Python": "import copy\n\nboardsize=6\n_kmoves = ((2,1), (1,2), (-1,2), (-2,1), (-2,-1), (-1,-2), (1,-2), (2,-1)) \n\n\ndef chess2index(chess, boardsize=boardsize):\n    'Convert Algebraic chess notation to internal index format'\n    chess = chess.strip().lower()\n    x = ord(chess[0]) - ord('a')\n    y = boardsize - int(chess[1:])\n    return (x, y)\n    \ndef boardstring(board, boardsize=boardsize):\n    r = range(boardsize)\n    lines = ''\n    for y in r:\n        lines += '\\n' + ','.join('%2i' % board[(x,y)] if board[(x,y)] else '  '\n                                 for x in r)\n    return lines\n    \ndef knightmoves(board, P, boardsize=boardsize):\n    Px, Py = P\n    kmoves = set((Px+x, Py+y) for x,y in _kmoves)\n    kmoves = set( (x,y)\n                  for x,y in kmoves\n                  if 0 <= x < boardsize\n                     and 0 <= y < boardsize\n                     and not board[(x,y)] )\n    return kmoves\n\ndef accessibility(board, P, boardsize=boardsize):\n    access = []\n    brd = copy.deepcopy(board)\n    for pos in knightmoves(board, P, boardsize=boardsize):\n        brd[pos] = -1\n        access.append( (len(knightmoves(brd, pos, boardsize=boardsize)), pos) )\n        brd[pos] = 0\n    return access\n    \ndef knights_tour(start, boardsize=boardsize, _debug=False):\n    board = {(x,y):0 for x in range(boardsize) for y in range(boardsize)}\n    move = 1\n    P = chess2index(start, boardsize)\n    board[P] = move\n    move += 1\n    if _debug:\n        print(boardstring(board, boardsize=boardsize))\n    while move <= len(board):\n        P = min(accessibility(board, P, boardsize))[1]\n        board[P] = move\n        move += 1\n        if _debug:\n            print(boardstring(board, boardsize=boardsize))\n            input('\\n%2i next: ' % move)\n    return board\n\nif __name__ == '__main__':\n    while 1:\n        boardsize = int(input('\\nboardsize: '))\n        if boardsize < 5:\n            continue\n        start = input('Start position: ')\n        board = knights_tour(start, boardsize)\n        print(boardstring(board, boardsize=boardsize))\n"},
    {"id": 23, "name": "9 billion names of God the integer", "Python": "cache = [[1]]\ndef cumu(n):\n    for l in range(len(cache), n+1):\n        r = [0]\n        for x in range(1, l+1):\n            r.append(r[-1] + cache[l-x][min(x, l-x)])\n        cache.append(r)\n    return cache[n]\n\ndef row(n):\n    r = cumu(n)\n    return [r[i+1] - r[i] for i in range(n)]\n\nprint \"rows:\"\nfor x in range(1, 11): print \"%2d:\"%x, row(x)\n\n\nprint \"\\nsums:\"\nfor x in [23, 123, 1234, 12345]: print x, cumu(x)[-1]\n", "C#": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace NamesOfGod\n{\n    public class RowSummer\n    {\n        const int N = 100000;\n        public BigInteger[] p;\n\n        private void calc(int n)\n            \n        {\n            p[n] = 0;\n\n            for (int k = 1; k <= n; k++)\n            {\n                int d = n - k * (3 * k - 1) / 2;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n\n                d -= k;\n                if (d < 0) break;\n\n                if ((k & 1) != 0) p[n] += p[d];\n                else p[n] -= p[d];\n            }\n\n        }\n        public void PrintSums()\n            \n        {\n            p = new BigInteger[N + 1];\n            var idx = new int[] { 23, 123, 1234, 12345, 20000, 30000, 40000, 50000, N, 0 };\n            int at = 0;\n\n            p[0] = 1;\n\n            for (int i = 1; idx[at] > 0; i++)\n            {\n                calc(i);\n                if (i != idx[at]) continue;\n                Console.WriteLine(i + \":\\t\" + p[i]);\n                at++;\n            }\n        }\n    }\n\n    public class RowPrinter\n        \n    {\n        List<List<int>> cache;\n        public RowPrinter()\n        {\n            cache = new List<List<int>> { new List<int> { 1 } };\n        }\n        public List<int> cumu(int n)\n        {\n            for (int l = cache.Count; l < n + 1; l++)\n            {\n                var r = new List<int> { 0 };\n                for (int x = 1; x < l + 1; x++)\n                    r.Add(r.Last() + cache[l - x][Math.Min(x, l - x)]);\n                cache.Add(r);\n            }\n            return cache[n];\n        }\n        public List<int> row(int n)\n        {\n            var r = cumu(n);\n            return (from i in Enumerable.Range(0, n) select r[i + 1] - r[i]).ToList();\n        }\n        public void PrintRows()\n        {\n            var rows = Enumerable.Range(1, 25).Select(x => string.Join(\" \", row(x))).ToList();\n            var widest = rows.Last().Length;\n            foreach (var r in rows)\n                Console.WriteLine(new String(' ', (widest - r.Length) / 2) + r);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args) \n        {\n            var rpr = new RowPrinter();\n            rpr.PrintRows();\n            var ros = new RowSummer();\n            ros.PrintSums();\n            Console.ReadLine();\n        }\n    }\n}\n"},
    {"id": 24, "name": "Balanced ternary", "Python": "class BalancedTernary:\n    \n\n    str2dig = {'+': 1, '-': -1, '0': 0} \n    dig2str = {1: '+', -1: '-', 0: '0'} \n    table = ((0, -1), (1, -1), (-1, 0), (0, 0), (1, 0), (-1, 1), (0, 1)) \n\n    def __init__(self, inp):\n        if isinstance(inp, str):\n            self.digits = [BalancedTernary.str2dig[c] for c in reversed(inp)]\n        elif isinstance(inp, int):\n            self.digits = self._int2ternary(inp)\n        elif isinstance(inp, BalancedTernary):\n            self.digits = list(inp.digits)\n        elif isinstance(inp, list):\n            if all(d in (0, 1, -1) for d in inp):\n                self.digits = list(inp)\n            else:\n                raise ValueError(\"BalancedTernary: Wrong input digits.\")\n        else:\n            raise TypeError(\"BalancedTernary: Wrong constructor input.\")\n\n    @staticmethod\n    def _int2ternary(n):\n        if n == 0: return []\n        if (n % 3) == 0: return [0] + BalancedTernary._int2ternary(n // 3)\n        if (n % 3) == 1: return [1] + BalancedTernary._int2ternary(n // 3)\n        if (n % 3) == 2: return [-1] + BalancedTernary._int2ternary((n + 1) // 3)\n\n    def to_int(self):\n        return reduce(lambda y,x: x + 3 * y, reversed(self.digits), 0)\n\n    def __repr__(self):\n        if not self.digits: return \"0\"\n        return \"\".join(BalancedTernary.dig2str[d] for d in reversed(self.digits))\n\n    @staticmethod\n    def _neg(digs):\n        return [-d for d in digs]\n\n    def __neg__(self):\n        return BalancedTernary(BalancedTernary._neg(self.digits))\n\n    @staticmethod\n    def _add(a, b, c=0):\n        if not (a and b):\n            if c == 0:\n                return a or b\n            else:\n                return BalancedTernary._add([c], a or b)\n        else:\n            (d, c) = BalancedTernary.table[3 + (a[0] if a else 0) + (b[0] if b else 0) + c]\n            res = BalancedTernary._add(a[1:], b[1:], c)\n            \n            if res or d != 0:\n                return [d] + res\n            else:\n                return res\n\n    def __add__(self, b):\n        return BalancedTernary(BalancedTernary._add(self.digits, b.digits))\n\n    def __sub__(self, b):\n        return self + (-b)\n\n    @staticmethod\n    def _mul(a, b):\n        if not (a and b):\n            return []\n        else:\n            if   a[0] == -1: x = BalancedTernary._neg(b)\n            elif a[0] ==  0: x = []\n            elif a[0] ==  1: x = b\n            else: assert False\n            y = [0] + BalancedTernary._mul(a[1:], b)\n            return BalancedTernary._add(x, y)\n\n    def __mul__(self, b):\n        return BalancedTernary(BalancedTernary._mul(self.digits, b.digits))\n\n\ndef main():\n    a = BalancedTernary(\"+-0++0+\")\n    print \"a:\", a.to_int(), a\n\n    b = BalancedTernary(-436)\n    print \"b:\", b.to_int(), b\n\n    c = BalancedTernary(\"+-++-\")\n    print \"c:\", c.to_int(), c\n\n    r = a * (b - c)\n    print \"a * (b - c):\", r.to_int(), r\n\nmain()\n", "C++": "#include <iostream>\n#include <string>\n#include <climits>\nusing namespace std;\n\nclass BalancedTernary {\nprotected:\n\t\n\tstring value;\n\n\t\n\tint charToInt(char c) const {\n\t\tif (c == '0')\n\t\t\treturn 0;\n\t\treturn 44 - c;\n\t}\n\n\t\n\tstring negate(string s) const {\n\t\tfor (int i = 0; i < s.length(); ++i) {\n\t\t\tif (s[i] == '+')\n\t\t\t\ts[i] = '-';\n\t\t\telse if (s[i] == '-')\n\t\t\t\ts[i] = '+';\n\t\t}\n\t\treturn s;\n\t}\n\npublic:\n\t\n\tBalancedTernary() {\n\t\tvalue = \"0\";\n\t}\n\n\t\n\tBalancedTernary(string s) {\n\t\tvalue = string(s.rbegin(), s.rend());\n\t}\n\n\t\n\tBalancedTernary(long long n) {\n\t\tif (n == 0) {\n\t\t\tvalue = \"0\";\n\t\t\treturn;\n\t\t}\n\n\t\tbool neg = n < 0;\n\t\tif (neg) \n\t\t\tn = -n;\n\n\t\tvalue = \"\";\n\t\twhile (n != 0) {\n\t\t\tint r = n % 3;\n\t\t\tif (r == 0)\n\t\t\t\tvalue += \"0\";\n\t\t\telse if (r == 1)\n\t\t\t\tvalue += \"+\";\n\t\t\telse {\n\t\t\t\tvalue += \"-\";\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t\tn /= 3;\n\t\t}\n\n\t\tif (neg)\n\t\t\tvalue = negate(value);\n\t}\n\n\t\n\tBalancedTernary(const BalancedTernary &n) {\n\t\tvalue = n.value;\n\t}\n\n\t\n\tBalancedTernary operator+(BalancedTernary n) const {\n\t\tn += *this;\n\t\treturn n;\n\t}\n\n\tBalancedTernary& operator+=(const BalancedTernary &n) {\n\t\tstatic char *add = \"0+-0+-0\";\n\t\tstatic char *carry = \"--000++\";\n\n\t\tint lastNonZero = 0;\n\t\tchar c = '0';\n\t\tfor (int i = 0; i < value.length() || i < n.value.length(); ++i) {\n\t\t\tchar a = i < value.length() ? value[i] : '0';\n\t\t\tchar b = i < n.value.length() ? n.value[i] : '0';\n\n\t\t\tint sum = charToInt(a) + charToInt(b) + charToInt(c) + 3;\n\t\t\tc = carry[sum];\n\n\t\t\tif (i < value.length())\n\t\t\t\tvalue[i] = add[sum];\n\t\t\telse\n\t\t\t\tvalue += add[sum];\n\n\t\t\tif (add[sum] != '0')\n\t\t\t\tlastNonZero = i;\n\t\t}\n\n\t\tif (c != '0')\n\t\t\tvalue += c;\n\t\telse\n\t\t\tvalue = value.substr(0, lastNonZero + 1); \n\n\t\treturn *this;\n\t}\n\n\t\n\tBalancedTernary operator-() const {\n\t\tBalancedTernary result;\n\t\tresult.value = negate(value);\n\t\treturn result;\n\t}\n\n\t\n\tBalancedTernary operator-(const BalancedTernary &n) const {\n\t\treturn operator+(-n);\n\t}\n\n\tBalancedTernary& operator-=(const BalancedTernary &n) {\n\t\treturn operator+=(-n);\n\t}\n\n\t\n\tBalancedTernary operator*(BalancedTernary n) const {\n\t\tn *= *this;\n\t\treturn n;\n\t}\n\n\tBalancedTernary& operator*=(const BalancedTernary &n) {\n\t\tBalancedTernary pos = *this;\n\t\tBalancedTernary neg = -pos; \n\t\tvalue = \"0\";\n\n\t\tfor (int i = 0; i < n.value.length(); ++i) {\n\t\t\tif (n.value[i] == '+')\n\t\t\t\toperator+=(pos);\n\t\t\telse if (n.value[i] == '-')\n\t\t\t\toperator+=(neg);\n\t\t\tpos.value = '0' + pos.value;\n\t\t\tneg.value = '0' + neg.value;\n\t\t}\n\n\t\treturn *this;\n\t}\n\n\t\n\tfriend ostream& operator<<(ostream &out, const BalancedTernary &n) {\n\t\tout << n.toString();\n\t\treturn out;\n\t}\n\n\t\n\tstring toString() const {\n\t\treturn string(value.rbegin(), value.rend());\n\t}\n\n\t\n\tlong long toInt() const {\n\t\tlong long result = 0;\n\t\tfor (long long i = 0, pow = 1; i < value.length(); ++i, pow *= 3)\n\t\t\tresult += pow * charToInt(value[i]);\n\t\treturn result;\n\t}\n\n\t\n\tbool tryInt(long long &out) const {\n\t\tlong long result = 0;\n\t\tbool ok = true;\n\n\t\tfor (long long i = 0, pow = 1; i < value.length() && ok; ++i, pow *= 3) {\n\t\t\tif (value[i] == '+') {\n\t\t\t\tok &= LLONG_MAX - pow >= result; \n\t\t\t\tresult += pow;\n\t\t\t} else if (value[i] == '-') {\n\t\t\t\tok &= LLONG_MIN + pow <= result; \n\t\t\t\tresult -= pow;\n\t\t\t}\n\t\t}\n\n\t\tif (ok)\n\t\t\tout = result;\n\t\treturn ok;\n\t}\n};\n\nint main() {\n\tBalancedTernary a(\"+-0++0+\");\n\tBalancedTernary b(-436);\n\tBalancedTernary c(\"+-++-\");\n\n\tcout << \"a = \" << a << \" = \" << a.toInt() << endl;\n\tcout << \"b = \" << b << \" = \" << b.toInt() << endl;\n\tcout << \"c = \" << c << \" = \" << c.toInt() << endl;\n\n\tBalancedTernary d = a * (b - c);\n\n\tcout << \"a * (b - c) = \" << d << \" = \" << d.toInt() << endl;\n\n\tBalancedTernary e(\"+++++++++++++++++++++++++++++++++++++++++\");\n\n\tlong long n;\n\tif (e.tryInt(n))\n\t\tcout << \"e = \" << e << \" = \" << n << endl;\n\telse\n\t\tcout << \"e = \" << e << \" is too big to fit in a long long\" << endl;\n\n\treturn 0;\n}\n"},
    {"id": 25, "name": "Mersenne primes", "Java": "import java.math.BigInteger;\n\npublic class MersennePrimes {\n    private static final int MAX = 20;\n\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n\n    private static boolean isPrime(int n) {\n        if (n < 2) return false;\n        if (n % 2 == 0) return n == 2;\n        if (n % 3 == 0) return n == 3;\n        int d = 5;\n        while (d * d <= n) {\n            if (n % d == 0) return false;\n            d += 2;\n            if (n % d == 0) return false;\n            d += 4;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        int count = 0;\n        int p = 2;\n        while (true) {\n            BigInteger m = TWO.shiftLeft(p - 1).subtract(ONE);\n            if (m.isProbablePrime(10)) {\n                System.out.printf(\"2 ^ %d - 1\\n\", p);\n                if (++count == MAX) break;\n            }\n            \n            do {\n                p = (p > 2) ? p + 2 : 3;\n            } while (!isPrime(p));\n        }\n    }\n}\n", "C#": "using System;\nusing System.Numerics;\n\nnamespace MersennePrimes {\n    class Program {\n        static BigInteger Sqrt(BigInteger x) {\n            if (x < 0) throw new ArgumentException(\"Negative argument.\");\n            if (x < 2) return x;\n            BigInteger y = x / 2;\n            while (y > x / y) {\n                y = ((x / y) + y) / 2;\n            }\n            return y;\n        }\n\n        static bool IsPrime(BigInteger bi) {\n            if (bi < 2) return false;\n            if (bi % 2 == 0) return bi == 2;\n            if (bi % 3 == 0) return bi == 3;\n            if (bi % 5 == 0) return bi == 5;\n            if (bi % 7 == 0) return bi == 7;\n            if (bi % 11 == 0) return bi == 11;\n            if (bi % 13 == 0) return bi == 13;\n            if (bi % 17 == 0) return bi == 17;\n            if (bi % 19 == 0) return bi == 19;\n\n            BigInteger limit = Sqrt(bi);\n            BigInteger test = 23;\n            while (test < limit) {\n                if (bi % test == 0) return false;\n                test += 2;\n                if (bi % test == 0) return false;\n                test += 4;\n            }\n\n            return true;\n        }\n\n        static void Main(string[] args) {\n            const int MAX = 9;\n\n            int pow = 2;\n            int count = 0;\n\n            while (true) {\n                if (IsPrime(pow)) {\n                    BigInteger p = BigInteger.Pow(2, pow) - 1;\n                    if (IsPrime(p)) {\n                        Console.WriteLine(\"2 ^ {0} - 1\", pow);\n                        if (++count >= MAX) {\n                            break;\n                        }\n                    }\n                }\n                pow++;\n            }\n        }\n    }\n}\n"},
    {"id": 26, "name": "Mersenne primes", "Go": "package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n\n\t\n\t\"math/big\"\n\t\n)\n\nfunc main() {\n\tstart := time.Now()\n\tone := big.NewInt(1)\n\tmp := big.NewInt(0)\n\tbp := big.NewInt(0)\n\tconst max = 22\n\tfor count, p := 0, uint(2); count < max; {\n\t\tmp.Lsh(one, p)\n\t\tmp.Sub(mp, one)\n\t\tif mp.ProbablyPrime(0) {\n\t\t\telapsed := time.Since(start).Seconds()\n\t\t\tif elapsed >= 0.01 {\n\t\t\t\tfmt.Printf(\"2 ^ %-4d - 1 took %6.2f secs\\n\", p, elapsed)\n\t\t\t} else {\n\t\t\t\tfmt.Printf(\"2 ^ %-4d - 1\\n\", p)\n\t\t\t}\n\t\t\tcount++\n\t\t}\n\t\tfor {\n\t\t\tif p > 2 {\n\t\t\t\tp += 2\n\t\t\t} else {\n\t\t\t\tp = 3\n\t\t\t}\n\t\t\tbp.SetUint64(uint64(p))\n\t\t\tif bp.ProbablyPrime(0) {\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n}\n", "C": "#include <stdbool.h>\n#include <stdint.h>\n#include <stdio.h>\n\nbool isPrime(uint64_t n) {\n    uint64_t test;\n\n    if (n < 2) return false;\n    if (n % 2 == 0) return n == 2;\n    if (n % 3 == 0) return n == 3;\n\n    test = 5;\n    while (test * test < n) {\n        if (n % test == 0) return false;\n        test += 2;\n        if (n % test == 0) return false;\n        test += 4;\n    }\n\n    return true;\n}\n\nint main() {\n    uint64_t base = 2;\n    int pow;\n\n    for (pow = 1; pow <= 32; pow++) {\n        if (isPrime(base - 1)) {\n            printf(\"2 ^ %d - 1\\n\", pow);\n        }\n        base *= 2;\n    }\n\n    return 0;\n}\n"},
    {"id": 27, "name": "Nimber arithmetic", "Java": "import java.util.function.IntBinaryOperator;\n\npublic class Nimber {\n    public static void main(String[] args) {\n        printTable(15, '+', (x, y) -> nimSum(x, y));\n        System.out.println();\n        printTable(15, '*', (x, y) -> nimProduct(x, y));\n        System.out.println();\n\n        int a = 21508, b = 42689;\n        System.out.println(a + \" + \" + b +  \" = \" + nimSum(a, b));\n        System.out.println(a + \" * \" + b +  \" = \" + nimProduct(a, b));\n    }\n\n    \n    public static int nimSum(int x, int y) {\n        return x ^ y;\n    }\n\n    \n    public static int nimProduct(int x, int y) {\n        if (x < 2 || y < 2)\n            return x * y;\n        int h = hpo2(x);\n        if (x > h)\n            return nimProduct(h, y) ^ nimProduct(x ^ h, y);\n        if (hpo2(y) < y)\n            return nimProduct(y, x);\n        int xp = lhpo2(x), yp = lhpo2(y);\n        int comp = xp & yp;\n        if (comp == 0)\n            return x * y;\n        h = hpo2(comp);\n        return nimProduct(nimProduct(x >> h, y >> h), 3 << (h - 1));\n    }\n\n    \n    private static int hpo2(int n) {\n        return n & -n;\n    }\n    \n    \n    private static int lhpo2(int n) {\n        int q = 0, m = hpo2(n);\n        for (; m % 2 == 0; m >>= 1, ++q) {}\n        return q;\n    }\n\n    private static void printTable(int n, char op, IntBinaryOperator func) {\n        System.out.print(\" \" + op + \" |\");\n        for (int a = 0; a <= n; ++a)\n            System.out.printf(\"%3d\", a);\n        System.out.print(\"\\n--- -\");\n        for (int a = 0; a <= n; ++a)\n            System.out.print(\"---\");\n        System.out.println();\n        for (int b = 0; b <= n; ++b) {\n            System.out.printf(\"%2d |\", b);\n            for (int a = 0; a <= n; ++a)\n                System.out.printf(\"%3d\", func.applyAsInt(a, b));\n            System.out.println();\n        }\n    }\n}\n", "C": "#include <stdio.h>\n#include <stdint.h>\n\n\nuint32_t hpo2(uint32_t n) {\n    return n & -n;\n}\n\n\nuint32_t lhpo2(uint32_t n) {\n    uint32_t q = 0, m = hpo2(n);\n    for (; m % 2 == 0; m >>= 1, ++q) {}\n    return q;\n}\n\n\nuint32_t nimsum(uint32_t x, uint32_t y) {\n    return x ^ y;\n}\n\n\nuint32_t nimprod(uint32_t x, uint32_t y) {\n    if (x < 2 || y < 2)\n        return x * y;\n    uint32_t h = hpo2(x);\n    if (x > h)\n        return nimprod(h, y) ^ nimprod(x ^ h, y);\n    if (hpo2(y) < y)\n        return nimprod(y, x);\n    uint32_t xp = lhpo2(x), yp = lhpo2(y);\n    uint32_t comp = xp & yp;\n    if (comp == 0)\n        return x * y;\n    h = hpo2(comp);\n    return nimprod(nimprod(x >> h, y >> h), 3 << (h - 1));\n}\n\nvoid print_table(uint32_t n, char op, uint32_t(*func)(uint32_t, uint32_t)) {\n    printf(\" %c |\", op);\n    for (uint32_t a = 0; a <= n; ++a)\n        printf(\"%3d\", a);\n    printf(\"\\n--- -\");\n    for (uint32_t a = 0; a <= n; ++a)\n        printf(\"---\");\n    printf(\"\\n\");\n    for (uint32_t b = 0; b <= n; ++b) {\n        printf(\"%2d |\", b);\n        for (uint32_t a = 0; a <= n; ++a)\n            printf(\"%3d\", func(a, b));\n        printf(\"\\n\");\n    }\n}\n\nint main() {\n    print_table(15, '+', nimsum);\n    printf(\"\\n\");\n    print_table(15, '*', nimprod);\n    const uint32_t a = 21508, b = 42689;\n    printf(\"\\n%d + %d = %d\\n\", a, b, nimsum(a, b));\n    printf(\"%d * %d = %d\\n\", a, b, nimprod(a, b));\n    return 0;\n}\n"},
    {"id": 28, "name": "Loop over multiple arrays simultaneously", "Go": "package main\n\nimport \"fmt\"\n\nvar a1 = []string{\"a\", \"b\", \"c\"}\nvar a2 = []byte{'A', 'B', 'C'}\nvar a3 = []int{1, 2, 3}\n\nfunc main() {\n\tfor i := range a1 {\n\t\tfmt.Printf(\"%v%c%v\\n\", a1[i], a2[i], a3[i])\n\t}\n}\n", "Java": "module LoopOverMultipleArrays\n    {\n    @Inject Console console;\n\n    void run()\n        {\n        Char[]   chars   = ['a', 'b', 'c'];\n        String[] strings = [\"A\", \"B\", \"C\"];\n        Int[]    ints    = [ 1,   2,   3 ];\n\n        console.print(\"Using array indexing:\");\n        for (Int i = 0, Int longest = chars.size.maxOf(strings.size.maxOf(ints.size)); i < longest; ++i)\n            {\n            console.print($|{i < chars.size   ? chars[i].toString() : \"\"}\\\n                           |{i < strings.size ? strings[i]          : \"\"}\\\n                           |{i < ints.size    ? ints[i].toString()  : \"\"}\n                         );\n            }\n\n        console.print(\"\\nUsing array iterators:\");\n        val charIter   = chars.iterator();\n        val stringIter = strings.iterator();\n        val intIter    = ints.iterator();\n        while (True)\n            {\n            StringBuffer buf = new StringBuffer();\n            if (Char ch := charIter.next())\n                {\n                buf.add(ch);\n                }\n            if (String s := stringIter.next())\n                {\n                s.appendTo(buf);\n                }\n            if (Int n := intIter.next())\n                {\n                n.appendTo(buf);\n                }\n            if (buf.size == 0)\n                {\n                break;\n                }\n            console.print(buf);\n            }\n        }\n    }\n"},
    {"id": 29, "name": "Vector products", "Python": "def crossp(a, b):\n    \n    assert len(a) == len(b) == 3, 'For 3D vectors only'\n    a1, a2, a3 = a\n    b1, b2, b3 = b\n    return (a2*b3 - a3*b2, a3*b1 - a1*b3, a1*b2 - a2*b1)\n \ndef dotp(a,b):\n    \n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n \ndef scalartriplep(a, b, c):\n    \n    return dotp(a, crossp(b, c))\n \ndef vectortriplep(a, b, c):\n    \n    return crossp(a, crossp(b, c))\n \nif __name__ == '__main__':\n    a, b, c = (3, 4, 5), (4, 3, 5), (-5, -12, -13)\n    print(\"a = %r;  b = %r;  c = %r\" % (a, b, c))\n    print(\"a . b = %r\" % dotp(a,b))\n    print(\"a x b = %r\"  % (crossp(a,b),))\n    print(\"a . (b x c) = %r\" % scalartriplep(a, b, c))\n    print(\"a x (b x c) = %r\" % (vectortriplep(a, b, c),))\n", "C": "#include<stdio.h>\n\ntypedef struct{\n\tfloat i,j,k;\n\t}Vector;\n\nVector a = {3, 4, 5},b = {4, 3, 5},c = {-5, -12, -13};\n\nfloat dotProduct(Vector a, Vector b)\n{\n\treturn a.i*b.i+a.j*b.j+a.k*b.k;\n}\n\nVector crossProduct(Vector a,Vector b)\n{\n\tVector c = {a.j*b.k - a.k*b.j, a.k*b.i - a.i*b.k, a.i*b.j - a.j*b.i};\n\t\n\treturn c;\n}\n\nfloat scalarTripleProduct(Vector a,Vector b,Vector c)\n{\n\treturn dotProduct(a,crossProduct(b,c));\n}\n\nVector vectorTripleProduct(Vector a,Vector b,Vector c)\n{\n\treturn crossProduct(a,crossProduct(b,c));\n}\n\nvoid printVector(Vector a)\n{\n\tprintf(\"( %f, %f, %f)\",a.i,a.j,a.k);\n}\n\nint main()\n{\n\tprintf(\"\\n a = \"); printVector(a);\n\tprintf(\"\\n b = \"); printVector(b);\n\tprintf(\"\\n c = \"); printVector(c);\n\tprintf(\"\\n a . b = %f\",dotProduct(a,b));\n\tprintf(\"\\n a x b = \"); printVector(crossProduct(a,b));\n\tprintf(\"\\n a . (b x c) = %f\",scalarTripleProduct(a,b,c));\n\tprintf(\"\\n a x (b x c) = \"); printVector(vectorTripleProduct(a,b,c));\n\t\n\treturn 0;\n}\n"},
    {"id": 30, "name": "Vector products", "Go": "package main\n\nimport \"fmt\"\n\ntype vector struct {\n    x, y, z float64\n}\n\nvar (\n    a = vector{3, 4, 5}\n    b = vector{4, 3, 5}\n    c = vector{-5, -12, -13}\n)\n\nfunc dot(a, b vector) float64 {\n    return a.x*b.x + a.y*b.y + a.z*b.z\n}\n\nfunc cross(a, b vector) vector {\n    return vector{a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x}\n}\n\nfunc s3(a, b, c vector) float64 {\n    return dot(a, cross(b, c))\n}\n\nfunc v3(a, b, c vector) vector {\n    return cross(a, cross(b, c))\n}\n\nfunc main() {\n    fmt.Println(dot(a, b))\n    fmt.Println(cross(a, b))\n    fmt.Println(s3(a, b, c))\n    fmt.Println(v3(a, b, c))\n}\n", "C++": "#include <iostream>\n\ntemplate< class T >\nclass D3Vector {\n\ntemplate< class U >\nfriend std::ostream & operator<<( std::ostream & , const D3Vector<U> & ) ;   \n\npublic :\n   D3Vector( T a , T b , T c ) {\n      x = a ;\n      y = b ;\n      z = c ;\n   }\n\n   T dotproduct ( const D3Vector & rhs ) {\n      T scalar = x * rhs.x + y * rhs.y + z * rhs.z ;\n      return scalar ;\n   }\n\n   D3Vector crossproduct ( const D3Vector & rhs ) {\n      T a = y * rhs.z - z * rhs.y ;\n      T b = z * rhs.x - x * rhs.z ;\n      T c = x * rhs.y - y * rhs.x ;\n      D3Vector product( a , b , c ) ;\n      return product ;\n   }\n\n   D3Vector triplevec( D3Vector & a , D3Vector & b ) {\n      return crossproduct ( a.crossproduct( b ) ) ;\n   }\n\n   T triplescal( D3Vector & a, D3Vector & b ) {\n      return dotproduct( a.crossproduct( b ) ) ;\n   }\n\nprivate :\n   T x , y , z ;  \n} ;\n\ntemplate< class T >\nstd::ostream & operator<< ( std::ostream & os , const D3Vector<T> & vec ) {\n   os << \"( \"  << vec.x << \" ,  \" << vec.y << \" ,  \" << vec.z << \" )\" ;\n   return os ;\n}\n\nint main( ) {\n   D3Vector<int> a( 3 , 4 , 5 ) , b ( 4 , 3 , 5 ) , c( -5 , -12 , -13 ) ;\n   std::cout << \"a . b : \" << a.dotproduct( b ) << \"\\n\" ;\n   std::cout << \"a x b : \" << a.crossproduct( b ) << \"\\n\" ;\n   std::cout << \"a . b x c : \" << a.triplescal( b , c ) << \"\\n\" ;\n   std::cout << \"a x b x c : \" << a.triplevec( b , c ) << \"\\n\" ;\n   return 0 ;\n}\n"}

]